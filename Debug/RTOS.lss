
RTOS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000fc6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000c  00800060  00000fc6  0000105a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000034  0080006c  0080006c  00001066  2**0
                  ALLOC
  3 .stab         000015f0  00000000  00000000  00001068  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000b3b  00000000  00000000  00002658  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 42 03 	jmp	0x684	; 0x684 <__vector_10>
  2c:	0c 94 07 03 	jmp	0x60e	; 0x60e <__vector_11>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e6 ec       	ldi	r30, 0xC6	; 198
  68:	ff e0       	ldi	r31, 0x0F	; 15
  6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
  70:	ac 36       	cpi	r26, 0x6C	; 108
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
  76:	10 e0       	ldi	r17, 0x00	; 0
  78:	ac e6       	ldi	r26, 0x6C	; 108
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a0 3a       	cpi	r26, 0xA0	; 160
  82:	b1 07       	cpc	r27, r17
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 44 07 	call	0xe88	; 0xe88 <main>
  8a:	0c 94 e1 07 	jmp	0xfc2	; 0xfc2 <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <OS_VOIDOSStart>:
/* Create an array of type Task_t for task management */
Task_t Tasks[NUMBER_OF_TASKS];

/* Initialization function for the OS */
void OS_VOIDOSStart (void)
{
  92:	df 93       	push	r29
  94:	cf 93       	push	r28
  96:	cd b7       	in	r28, 0x3d	; 61
  98:	de b7       	in	r29, 0x3e	; 62
    /* Enable Global Interrupt */
    MGIE_VOIDEnable();
  9a:	0e 94 6f 03 	call	0x6de	; 0x6de <MGIE_VOIDEnable>

    /* Initialize Timer0 in CTC mode */
    MTMR0_VOIDCTCInit();
  9e:	0e 94 f4 01 	call	0x3e8	; 0x3e8 <MTMR0_VOIDCTCInit>
}
  a2:	cf 91       	pop	r28
  a4:	df 91       	pop	r29
  a6:	08 95       	ret

000000a8 <OS_VOIDCreateTask>:

/* Function to create tasks and list them according to their priority in the task array */
void OS_VOIDCreateTask (void (*Copy_VOIDptf) (void), u8 Copy_U8Priority, u16 Copy_U16Periodicity)
{
  a8:	df 93       	push	r29
  aa:	cf 93       	push	r28
  ac:	00 d0       	rcall	.+0      	; 0xae <OS_VOIDCreateTask+0x6>
  ae:	00 d0       	rcall	.+0      	; 0xb0 <OS_VOIDCreateTask+0x8>
  b0:	0f 92       	push	r0
  b2:	cd b7       	in	r28, 0x3d	; 61
  b4:	de b7       	in	r29, 0x3e	; 62
  b6:	9a 83       	std	Y+2, r25	; 0x02
  b8:	89 83       	std	Y+1, r24	; 0x01
  ba:	6b 83       	std	Y+3, r22	; 0x03
  bc:	5d 83       	std	Y+5, r21	; 0x05
  be:	4c 83       	std	Y+4, r20	; 0x04
    Tasks[Copy_U8Priority].periodicity = Copy_U16Periodicity;  /* Set task periodicity */
  c0:	8b 81       	ldd	r24, Y+3	; 0x03
  c2:	88 2f       	mov	r24, r24
  c4:	90 e0       	ldi	r25, 0x00	; 0
  c6:	88 0f       	add	r24, r24
  c8:	99 1f       	adc	r25, r25
  ca:	01 96       	adiw	r24, 0x01	; 1
  cc:	88 0f       	add	r24, r24
  ce:	99 1f       	adc	r25, r25
  d0:	fc 01       	movw	r30, r24
  d2:	ec 58       	subi	r30, 0x8C	; 140
  d4:	ff 4f       	sbci	r31, 0xFF	; 255
  d6:	8c 81       	ldd	r24, Y+4	; 0x04
  d8:	9d 81       	ldd	r25, Y+5	; 0x05
  da:	91 83       	std	Z+1, r25	; 0x01
  dc:	80 83       	st	Z, r24
    Tasks[Copy_U8Priority].ptf = Copy_VOIDptf;                  /* Set task function pointer */
  de:	8b 81       	ldd	r24, Y+3	; 0x03
  e0:	88 2f       	mov	r24, r24
  e2:	90 e0       	ldi	r25, 0x00	; 0
  e4:	88 0f       	add	r24, r24
  e6:	99 1f       	adc	r25, r25
  e8:	88 0f       	add	r24, r24
  ea:	99 1f       	adc	r25, r25
  ec:	fc 01       	movw	r30, r24
  ee:	ec 58       	subi	r30, 0x8C	; 140
  f0:	ff 4f       	sbci	r31, 0xFF	; 255
  f2:	89 81       	ldd	r24, Y+1	; 0x01
  f4:	9a 81       	ldd	r25, Y+2	; 0x02
  f6:	91 83       	std	Z+1, r25	; 0x01
  f8:	80 83       	st	Z, r24
}
  fa:	0f 90       	pop	r0
  fc:	0f 90       	pop	r0
  fe:	0f 90       	pop	r0
 100:	0f 90       	pop	r0
 102:	0f 90       	pop	r0
 104:	cf 91       	pop	r28
 106:	df 91       	pop	r29
 108:	08 95       	ret

0000010a <OS_VOIDSchedular>:

/* Scheduler function to manage the execution of tasks based on their periodicity */
void OS_VOIDSchedular (void)
{
 10a:	df 93       	push	r29
 10c:	cf 93       	push	r28
 10e:	0f 92       	push	r0
 110:	cd b7       	in	r28, 0x3d	; 61
 112:	de b7       	in	r29, 0x3e	; 62
    GLOB_U16TickNum++;  /* Increment the global tick */
 114:	80 91 6c 00 	lds	r24, 0x006C
 118:	90 91 6d 00 	lds	r25, 0x006D
 11c:	01 96       	adiw	r24, 0x01	; 1
 11e:	90 93 6d 00 	sts	0x006D, r25
 122:	80 93 6c 00 	sts	0x006C, r24

    /* Iterate through all tasks to check if they should be executed */
    for (u8 LOC_U8Iterator = 0; LOC_U8Iterator < NUMBER_OF_TASKS; LOC_U8Iterator++)
 126:	19 82       	std	Y+1, r1	; 0x01
 128:	28 c0       	rjmp	.+80     	; 0x17a <OS_VOIDSchedular+0x70>
    {
        /* Execute the task if it's time based on its periodicity */
        if ((GLOB_U16TickNum % Tasks[LOC_U8Iterator].periodicity) == 0)
 12a:	40 91 6c 00 	lds	r20, 0x006C
 12e:	50 91 6d 00 	lds	r21, 0x006D
 132:	89 81       	ldd	r24, Y+1	; 0x01
 134:	88 2f       	mov	r24, r24
 136:	90 e0       	ldi	r25, 0x00	; 0
 138:	88 0f       	add	r24, r24
 13a:	99 1f       	adc	r25, r25
 13c:	01 96       	adiw	r24, 0x01	; 1
 13e:	88 0f       	add	r24, r24
 140:	99 1f       	adc	r25, r25
 142:	fc 01       	movw	r30, r24
 144:	ec 58       	subi	r30, 0x8C	; 140
 146:	ff 4f       	sbci	r31, 0xFF	; 255
 148:	20 81       	ld	r18, Z
 14a:	31 81       	ldd	r19, Z+1	; 0x01
 14c:	ca 01       	movw	r24, r20
 14e:	b9 01       	movw	r22, r18
 150:	0e 94 ba 07 	call	0xf74	; 0xf74 <__udivmodhi4>
 154:	00 97       	sbiw	r24, 0x00	; 0
 156:	71 f4       	brne	.+28     	; 0x174 <OS_VOIDSchedular+0x6a>
        {
            Tasks[LOC_U8Iterator].ptf();
 158:	89 81       	ldd	r24, Y+1	; 0x01
 15a:	88 2f       	mov	r24, r24
 15c:	90 e0       	ldi	r25, 0x00	; 0
 15e:	88 0f       	add	r24, r24
 160:	99 1f       	adc	r25, r25
 162:	88 0f       	add	r24, r24
 164:	99 1f       	adc	r25, r25
 166:	fc 01       	movw	r30, r24
 168:	ec 58       	subi	r30, 0x8C	; 140
 16a:	ff 4f       	sbci	r31, 0xFF	; 255
 16c:	01 90       	ld	r0, Z+
 16e:	f0 81       	ld	r31, Z
 170:	e0 2d       	mov	r30, r0
 172:	09 95       	icall
void OS_VOIDSchedular (void)
{
    GLOB_U16TickNum++;  /* Increment the global tick */

    /* Iterate through all tasks to check if they should be executed */
    for (u8 LOC_U8Iterator = 0; LOC_U8Iterator < NUMBER_OF_TASKS; LOC_U8Iterator++)
 174:	89 81       	ldd	r24, Y+1	; 0x01
 176:	8f 5f       	subi	r24, 0xFF	; 255
 178:	89 83       	std	Y+1, r24	; 0x01
 17a:	89 81       	ldd	r24, Y+1	; 0x01
 17c:	8b 30       	cpi	r24, 0x0B	; 11
 17e:	a8 f2       	brcs	.-86     	; 0x12a <OS_VOIDSchedular+0x20>
        if ((GLOB_U16TickNum % Tasks[LOC_U8Iterator].periodicity) == 0)
        {
            Tasks[LOC_U8Iterator].ptf();
        }
    }
}
 180:	0f 90       	pop	r0
 182:	cf 91       	pop	r28
 184:	df 91       	pop	r29
 186:	08 95       	ret

00000188 <OS_VOIDAnimationFlag>:

/* Global flag to control animation state */
u8 GLOB_U8Flag = 0;
void OS_VOIDAnimationFlag (void)
{
 188:	df 93       	push	r29
 18a:	cf 93       	push	r28
 18c:	cd b7       	in	r28, 0x3d	; 61
 18e:	de b7       	in	r29, 0x3e	; 62
    GLOB_U8Flag = 1;  /* Set the animation flag */
 190:	81 e0       	ldi	r24, 0x01	; 1
 192:	80 93 6e 00 	sts	0x006E, r24
}
 196:	cf 91       	pop	r28
 198:	df 91       	pop	r29
 19a:	08 95       	ret

0000019c <OS_VOIDAnimation1_1>:

/* Animation on PORTC: Pattern 1 - Stage 1 */
void OS_VOIDAnimation1_1 (void)
{
 19c:	df 93       	push	r29
 19e:	cf 93       	push	r28
 1a0:	cd b7       	in	r28, 0x3d	; 61
 1a2:	de b7       	in	r29, 0x3e	; 62
    MDIO_VOIDSetPortValue(2, 0x18);  /* Set PORTC value to 0x18 */
 1a4:	82 e0       	ldi	r24, 0x02	; 2
 1a6:	68 e1       	ldi	r22, 0x18	; 24
 1a8:	0e 94 04 05 	call	0xa08	; 0xa08 <MDIO_VOIDSetPortValue>
}
 1ac:	cf 91       	pop	r28
 1ae:	df 91       	pop	r29
 1b0:	08 95       	ret

000001b2 <OS_VOIDAnimation1_2>:

/* Animation on PORTC: Pattern 1 - Stage 2 */
void OS_VOIDAnimation1_2 (void)
{
 1b2:	df 93       	push	r29
 1b4:	cf 93       	push	r28
 1b6:	cd b7       	in	r28, 0x3d	; 61
 1b8:	de b7       	in	r29, 0x3e	; 62
    MDIO_VOIDSetPortValue(2, 0b00111100);  /* Set PORTC value to 0b00111100 */
 1ba:	82 e0       	ldi	r24, 0x02	; 2
 1bc:	6c e3       	ldi	r22, 0x3C	; 60
 1be:	0e 94 04 05 	call	0xa08	; 0xa08 <MDIO_VOIDSetPortValue>
}
 1c2:	cf 91       	pop	r28
 1c4:	df 91       	pop	r29
 1c6:	08 95       	ret

000001c8 <OS_VOIDAnimation1_3>:

/* Animation on PORTC: Pattern 1 - Stage 3 */
void OS_VOIDAnimation1_3 (void)
{
 1c8:	df 93       	push	r29
 1ca:	cf 93       	push	r28
 1cc:	cd b7       	in	r28, 0x3d	; 61
 1ce:	de b7       	in	r29, 0x3e	; 62
    MDIO_VOIDSetPortValue(2, 0b01111110);  /* Set PORTC value to 0b01111110 */
 1d0:	82 e0       	ldi	r24, 0x02	; 2
 1d2:	6e e7       	ldi	r22, 0x7E	; 126
 1d4:	0e 94 04 05 	call	0xa08	; 0xa08 <MDIO_VOIDSetPortValue>
}
 1d8:	cf 91       	pop	r28
 1da:	df 91       	pop	r29
 1dc:	08 95       	ret

000001de <OS_VOIDAnimation1_4>:

/* Animation on PORTC: Pattern 1 - Stage 4 */
void OS_VOIDAnimation1_4 (void)
{
 1de:	df 93       	push	r29
 1e0:	cf 93       	push	r28
 1e2:	cd b7       	in	r28, 0x3d	; 61
 1e4:	de b7       	in	r29, 0x3e	; 62
    MDIO_VOIDSetPortValue(2, 0b11111111);  /* Set PORTC value to 0b11111111 */
 1e6:	82 e0       	ldi	r24, 0x02	; 2
 1e8:	6f ef       	ldi	r22, 0xFF	; 255
 1ea:	0e 94 04 05 	call	0xa08	; 0xa08 <MDIO_VOIDSetPortValue>
}
 1ee:	cf 91       	pop	r28
 1f0:	df 91       	pop	r29
 1f2:	08 95       	ret

000001f4 <OS_VOIDAnimation2_1>:

/* Animation on PORTC: Pattern 2 - Stage 1 */
void OS_VOIDAnimation2_1 (void)
{
 1f4:	df 93       	push	r29
 1f6:	cf 93       	push	r28
 1f8:	cd b7       	in	r28, 0x3d	; 61
 1fa:	de b7       	in	r29, 0x3e	; 62
    MDIO_VOIDSetPortValue(2, 0b01111110);  /* Set PORTC value to 0b01111110 */
 1fc:	82 e0       	ldi	r24, 0x02	; 2
 1fe:	6e e7       	ldi	r22, 0x7E	; 126
 200:	0e 94 04 05 	call	0xa08	; 0xa08 <MDIO_VOIDSetPortValue>
}
 204:	cf 91       	pop	r28
 206:	df 91       	pop	r29
 208:	08 95       	ret

0000020a <OS_VOIDAnimation2_2>:

/* Animation on PORTC: Pattern 2 - Stage 2 */
void OS_VOIDAnimation2_2 (void)
{
 20a:	df 93       	push	r29
 20c:	cf 93       	push	r28
 20e:	cd b7       	in	r28, 0x3d	; 61
 210:	de b7       	in	r29, 0x3e	; 62
    MDIO_VOIDSetPortValue(2, 0b00111100);  /* Set PORTC value to 0b00111100 */
 212:	82 e0       	ldi	r24, 0x02	; 2
 214:	6c e3       	ldi	r22, 0x3C	; 60
 216:	0e 94 04 05 	call	0xa08	; 0xa08 <MDIO_VOIDSetPortValue>
}
 21a:	cf 91       	pop	r28
 21c:	df 91       	pop	r29
 21e:	08 95       	ret

00000220 <OS_VOIDAnimation2_3>:

/* Animation on PORTC: Pattern 2 - Stage 3 */
void OS_VOIDAnimation2_3 (void)
{
 220:	df 93       	push	r29
 222:	cf 93       	push	r28
 224:	cd b7       	in	r28, 0x3d	; 61
 226:	de b7       	in	r29, 0x3e	; 62
    MDIO_VOIDSetPortValue(2, 0b00011000);  /* Set PORTC value to 0b00011000 */
 228:	82 e0       	ldi	r24, 0x02	; 2
 22a:	68 e1       	ldi	r22, 0x18	; 24
 22c:	0e 94 04 05 	call	0xa08	; 0xa08 <MDIO_VOIDSetPortValue>
}
 230:	cf 91       	pop	r28
 232:	df 91       	pop	r29
 234:	08 95       	ret

00000236 <OS_VOIDAnimation2_4>:

/* Animation on PORTC: Pattern 2 - Stage 4 */
void OS_VOIDAnimation2_4 (void)
{
 236:	df 93       	push	r29
 238:	cf 93       	push	r28
 23a:	cd b7       	in	r28, 0x3d	; 61
 23c:	de b7       	in	r29, 0x3e	; 62
    MDIO_VOIDSetPortValue(2, 0b00000000);  /* Set PORTC value to 0b00000000 */
 23e:	82 e0       	ldi	r24, 0x02	; 2
 240:	60 e0       	ldi	r22, 0x00	; 0
 242:	0e 94 04 05 	call	0xa08	; 0xa08 <MDIO_VOIDSetPortValue>
}
 246:	cf 91       	pop	r28
 248:	df 91       	pop	r29
 24a:	08 95       	ret

0000024c <OS_VOIDSegUp>:
/* Array of numbers to display on 7-segment display */
u8 GLOB_U8Numbers[10] = {ZERO, ONE, TWO, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE};

/* 7-Segment count-up function, to display on PORTA */
void OS_VOIDSegUp (void)
{
 24c:	df 93       	push	r29
 24e:	cf 93       	push	r28
 250:	cd b7       	in	r28, 0x3d	; 61
 252:	de b7       	in	r29, 0x3e	; 62
    static u8 LOC_U8Counter1 = 0;

    LOC_U8Counter1++;  /* Increment counter */
 254:	80 91 6f 00 	lds	r24, 0x006F
 258:	8f 5f       	subi	r24, 0xFF	; 255
 25a:	80 93 6f 00 	sts	0x006F, r24
    MDIO_VOIDSetPortValue(0, GLOB_U8Numbers[LOC_U8Counter1]);  /* Set PORTA value based on counter */
 25e:	80 91 6f 00 	lds	r24, 0x006F
 262:	88 2f       	mov	r24, r24
 264:	90 e0       	ldi	r25, 0x00	; 0
 266:	fc 01       	movw	r30, r24
 268:	e0 5a       	subi	r30, 0xA0	; 160
 26a:	ff 4f       	sbci	r31, 0xFF	; 255
 26c:	90 81       	ld	r25, Z
 26e:	80 e0       	ldi	r24, 0x00	; 0
 270:	69 2f       	mov	r22, r25
 272:	0e 94 04 05 	call	0xa08	; 0xa08 <MDIO_VOIDSetPortValue>

    /* If counter reaches 9, reset to 0 */
    if (GLOB_U8Numbers[LOC_U8Counter1] == NINE)
 276:	80 91 6f 00 	lds	r24, 0x006F
 27a:	88 2f       	mov	r24, r24
 27c:	90 e0       	ldi	r25, 0x00	; 0
 27e:	fc 01       	movw	r30, r24
 280:	e0 5a       	subi	r30, 0xA0	; 160
 282:	ff 4f       	sbci	r31, 0xFF	; 255
 284:	80 81       	ld	r24, Z
 286:	8f 36       	cpi	r24, 0x6F	; 111
 288:	79 f4       	brne	.+30     	; 0x2a8 <OS_VOIDSegUp+0x5c>
    {
        MDIO_VOIDSetPortValue(0, GLOB_U8Numbers[LOC_U8Counter1]);
 28a:	80 91 6f 00 	lds	r24, 0x006F
 28e:	88 2f       	mov	r24, r24
 290:	90 e0       	ldi	r25, 0x00	; 0
 292:	fc 01       	movw	r30, r24
 294:	e0 5a       	subi	r30, 0xA0	; 160
 296:	ff 4f       	sbci	r31, 0xFF	; 255
 298:	90 81       	ld	r25, Z
 29a:	80 e0       	ldi	r24, 0x00	; 0
 29c:	69 2f       	mov	r22, r25
 29e:	0e 94 04 05 	call	0xa08	; 0xa08 <MDIO_VOIDSetPortValue>
        LOC_U8Counter1 = -1;  /* Reset counter */
 2a2:	8f ef       	ldi	r24, 0xFF	; 255
 2a4:	80 93 6f 00 	sts	0x006F, r24
    }
}
 2a8:	cf 91       	pop	r28
 2aa:	df 91       	pop	r29
 2ac:	08 95       	ret

000002ae <OS_VOIDSegDown>:

/* 7-Segment count-down function, to display on PORTB */
void OS_VOIDSegDown (void)
{
 2ae:	df 93       	push	r29
 2b0:	cf 93       	push	r28
 2b2:	cd b7       	in	r28, 0x3d	; 61
 2b4:	de b7       	in	r29, 0x3e	; 62
    static u8 LOC_U8Counter2 = 9;

    /* If counter reaches 0, reset to 10 */
    if (GLOB_U8Numbers[LOC_U8Counter2] == ZERO)
 2b6:	80 91 6a 00 	lds	r24, 0x006A
 2ba:	88 2f       	mov	r24, r24
 2bc:	90 e0       	ldi	r25, 0x00	; 0
 2be:	fc 01       	movw	r30, r24
 2c0:	e0 5a       	subi	r30, 0xA0	; 160
 2c2:	ff 4f       	sbci	r31, 0xFF	; 255
 2c4:	80 81       	ld	r24, Z
 2c6:	8f 33       	cpi	r24, 0x3F	; 63
 2c8:	79 f4       	brne	.+30     	; 0x2e8 <OS_VOIDSegDown+0x3a>
    {
        MDIO_VOIDSetPortValue(1, GLOB_U8Numbers[LOC_U8Counter2]);
 2ca:	80 91 6a 00 	lds	r24, 0x006A
 2ce:	88 2f       	mov	r24, r24
 2d0:	90 e0       	ldi	r25, 0x00	; 0
 2d2:	fc 01       	movw	r30, r24
 2d4:	e0 5a       	subi	r30, 0xA0	; 160
 2d6:	ff 4f       	sbci	r31, 0xFF	; 255
 2d8:	90 81       	ld	r25, Z
 2da:	81 e0       	ldi	r24, 0x01	; 1
 2dc:	69 2f       	mov	r22, r25
 2de:	0e 94 04 05 	call	0xa08	; 0xa08 <MDIO_VOIDSetPortValue>
        LOC_U8Counter2 = 10;  /* Reset counter */
 2e2:	8a e0       	ldi	r24, 0x0A	; 10
 2e4:	80 93 6a 00 	sts	0x006A, r24
    }

    LOC_U8Counter2--;  /* Decrement counter */
 2e8:	80 91 6a 00 	lds	r24, 0x006A
 2ec:	81 50       	subi	r24, 0x01	; 1
 2ee:	80 93 6a 00 	sts	0x006A, r24
    MDIO_VOIDSetPortValue(1, GLOB_U8Numbers[LOC_U8Counter2]);  /* Set PORTB value based on counter */
 2f2:	80 91 6a 00 	lds	r24, 0x006A
 2f6:	88 2f       	mov	r24, r24
 2f8:	90 e0       	ldi	r25, 0x00	; 0
 2fa:	fc 01       	movw	r30, r24
 2fc:	e0 5a       	subi	r30, 0xA0	; 160
 2fe:	ff 4f       	sbci	r31, 0xFF	; 255
 300:	90 81       	ld	r25, Z
 302:	81 e0       	ldi	r24, 0x01	; 1
 304:	69 2f       	mov	r22, r25
 306:	0e 94 04 05 	call	0xa08	; 0xa08 <MDIO_VOIDSetPortValue>
}
 30a:	cf 91       	pop	r28
 30c:	df 91       	pop	r29
 30e:	08 95       	ret

00000310 <OS_VOIDDoorChangePosition>:

/* Door lock change position function, to display on PORTD */
void OS_VOIDDoorChangePosition (void)
{
 310:	df 93       	push	r29
 312:	cf 93       	push	r28
 314:	cd b7       	in	r28, 0x3d	; 61
 316:	de b7       	in	r29, 0x3e	; 62
    static u8 LOC_U8Position = 0;

    /* Change position of door lock */
    if (LOC_U8Position == 0)
 318:	80 91 70 00 	lds	r24, 0x0070
 31c:	88 23       	and	r24, r24
 31e:	71 f4       	brne	.+28     	; 0x33c <OS_VOIDDoorChangePosition+0x2c>
    {
        LOC_U8Position = 1;
 320:	81 e0       	ldi	r24, 0x01	; 1
 322:	80 93 70 00 	sts	0x0070, r24
        MDIO_VOIDSetPinValue(3, 0, 1);  /* Set PORTD pin 0 to high */
 326:	83 e0       	ldi	r24, 0x03	; 3
 328:	60 e0       	ldi	r22, 0x00	; 0
 32a:	41 e0       	ldi	r20, 0x01	; 1
 32c:	0e 94 45 05 	call	0xa8a	; 0xa8a <MDIO_VOIDSetPinValue>
        MDIO_VOIDSetPinValue(3, 7, 0);  /* Set PORTD pin 7 to low */
 330:	83 e0       	ldi	r24, 0x03	; 3
 332:	67 e0       	ldi	r22, 0x07	; 7
 334:	40 e0       	ldi	r20, 0x00	; 0
 336:	0e 94 45 05 	call	0xa8a	; 0xa8a <MDIO_VOIDSetPinValue>
 33a:	10 c0       	rjmp	.+32     	; 0x35c <OS_VOIDDoorChangePosition+0x4c>
    }
    else if (LOC_U8Position == 1)
 33c:	80 91 70 00 	lds	r24, 0x0070
 340:	81 30       	cpi	r24, 0x01	; 1
 342:	61 f4       	brne	.+24     	; 0x35c <OS_VOIDDoorChangePosition+0x4c>
    {
        LOC_U8Position = 0;
 344:	10 92 70 00 	sts	0x0070, r1
        MDIO_VOIDSetPinValue(3, 0, 0);  /* Set PORTD pin 0 to low */
 348:	83 e0       	ldi	r24, 0x03	; 3
 34a:	60 e0       	ldi	r22, 0x00	; 0
 34c:	40 e0       	ldi	r20, 0x00	; 0
 34e:	0e 94 45 05 	call	0xa8a	; 0xa8a <MDIO_VOIDSetPinValue>
        MDIO_VOIDSetPinValue(3, 7, 1);  /* Set PORTD pin 7 to high */
 352:	83 e0       	ldi	r24, 0x03	; 3
 354:	67 e0       	ldi	r22, 0x07	; 7
 356:	41 e0       	ldi	r20, 0x01	; 1
 358:	0e 94 45 05 	call	0xa8a	; 0xa8a <MDIO_VOIDSetPinValue>
    }
}
 35c:	cf 91       	pop	r28
 35e:	df 91       	pop	r29
 360:	08 95       	ret

00000362 <MTMR0_VOIDOVInitialization>:
 * Description: Initializes Timer0 in Normal mode for overflow interrupt.
 *  - Configures the timer mode, clock source, and pre-scaler.
 *  - Enables the overflow interrupt and sets the pre-load value for the counter.
 ************************************************************************************/
void MTMR0_VOIDOVInitialization (void)
{
 362:	df 93       	push	r29
 364:	cf 93       	push	r28
 366:	cd b7       	in	r28, 0x3d	; 61
 368:	de b7       	in	r29, 0x3e	; 62
	/* Select Normal Mode: Clear WGM00 and WGM01 */
	CLR_BIT(TCCR0_REG,6);
 36a:	a3 e5       	ldi	r26, 0x53	; 83
 36c:	b0 e0       	ldi	r27, 0x00	; 0
 36e:	e3 e5       	ldi	r30, 0x53	; 83
 370:	f0 e0       	ldi	r31, 0x00	; 0
 372:	80 81       	ld	r24, Z
 374:	8f 7b       	andi	r24, 0xBF	; 191
 376:	8c 93       	st	X, r24
	CLR_BIT(TCCR0_REG,3);
 378:	a3 e5       	ldi	r26, 0x53	; 83
 37a:	b0 e0       	ldi	r27, 0x00	; 0
 37c:	e3 e5       	ldi	r30, 0x53	; 83
 37e:	f0 e0       	ldi	r31, 0x00	; 0
 380:	80 81       	ld	r24, Z
 382:	87 7f       	andi	r24, 0xF7	; 247
 384:	8c 93       	st	X, r24
	/* Compare match output behavior depends on normal mode */
	CLR_BIT(TCCR0_REG,5);
 386:	a3 e5       	ldi	r26, 0x53	; 83
 388:	b0 e0       	ldi	r27, 0x00	; 0
 38a:	e3 e5       	ldi	r30, 0x53	; 83
 38c:	f0 e0       	ldi	r31, 0x00	; 0
 38e:	80 81       	ld	r24, Z
 390:	8f 7d       	andi	r24, 0xDF	; 223
 392:	8c 93       	st	X, r24
	CLR_BIT(TCCR0_REG,4);
 394:	a3 e5       	ldi	r26, 0x53	; 83
 396:	b0 e0       	ldi	r27, 0x00	; 0
 398:	e3 e5       	ldi	r30, 0x53	; 83
 39a:	f0 e0       	ldi	r31, 0x00	; 0
 39c:	80 81       	ld	r24, Z
 39e:	8f 7e       	andi	r24, 0xEF	; 239
 3a0:	8c 93       	st	X, r24
	/* Choose clock source: /1024 from pre-scalar */
	SET_BIT(TCCR0_REG,2);
 3a2:	a3 e5       	ldi	r26, 0x53	; 83
 3a4:	b0 e0       	ldi	r27, 0x00	; 0
 3a6:	e3 e5       	ldi	r30, 0x53	; 83
 3a8:	f0 e0       	ldi	r31, 0x00	; 0
 3aa:	80 81       	ld	r24, Z
 3ac:	84 60       	ori	r24, 0x04	; 4
 3ae:	8c 93       	st	X, r24
	CLR_BIT(TCCR0_REG,1);
 3b0:	a3 e5       	ldi	r26, 0x53	; 83
 3b2:	b0 e0       	ldi	r27, 0x00	; 0
 3b4:	e3 e5       	ldi	r30, 0x53	; 83
 3b6:	f0 e0       	ldi	r31, 0x00	; 0
 3b8:	80 81       	ld	r24, Z
 3ba:	8d 7f       	andi	r24, 0xFD	; 253
 3bc:	8c 93       	st	X, r24
	SET_BIT(TCCR0_REG,0);
 3be:	a3 e5       	ldi	r26, 0x53	; 83
 3c0:	b0 e0       	ldi	r27, 0x00	; 0
 3c2:	e3 e5       	ldi	r30, 0x53	; 83
 3c4:	f0 e0       	ldi	r31, 0x00	; 0
 3c6:	80 81       	ld	r24, Z
 3c8:	81 60       	ori	r24, 0x01	; 1
 3ca:	8c 93       	st	X, r24
	/* Enable TOIE0 overflow interrupt enable */
	SET_BIT(TIMSK_REG,0);
 3cc:	a9 e5       	ldi	r26, 0x59	; 89
 3ce:	b0 e0       	ldi	r27, 0x00	; 0
 3d0:	e9 e5       	ldi	r30, 0x59	; 89
 3d2:	f0 e0       	ldi	r31, 0x00	; 0
 3d4:	80 81       	ld	r24, Z
 3d6:	81 60       	ori	r24, 0x01	; 1
 3d8:	8c 93       	st	X, r24
	/* Pre-load value to start the counter */
	TCNT0_REG=123;
 3da:	e2 e5       	ldi	r30, 0x52	; 82
 3dc:	f0 e0       	ldi	r31, 0x00	; 0
 3de:	8b e7       	ldi	r24, 0x7B	; 123
 3e0:	80 83       	st	Z, r24
}
 3e2:	cf 91       	pop	r28
 3e4:	df 91       	pop	r29
 3e6:	08 95       	ret

000003e8 <MTMR0_VOIDCTCInit>:
 * Description: Initializes Timer0 in CTC mode for compare match interrupt.
 *  - Configures the timer mode, clock source, and pre-scaler.
 *  - Sets the top value to generate an interrupt every 1ms.
 ************************************************************************************/
void MTMR0_VOIDCTCInit (void)
{
 3e8:	df 93       	push	r29
 3ea:	cf 93       	push	r28
 3ec:	cd b7       	in	r28, 0x3d	; 61
 3ee:	de b7       	in	r29, 0x3e	; 62
	/* Select CTC Mode: Set WGM01 and clear WGM00 */
	SET_BIT(TCCR0_REG,6);
 3f0:	a3 e5       	ldi	r26, 0x53	; 83
 3f2:	b0 e0       	ldi	r27, 0x00	; 0
 3f4:	e3 e5       	ldi	r30, 0x53	; 83
 3f6:	f0 e0       	ldi	r31, 0x00	; 0
 3f8:	80 81       	ld	r24, Z
 3fa:	80 64       	ori	r24, 0x40	; 64
 3fc:	8c 93       	st	X, r24
	CLR_BIT(TCCR0_REG,3);
 3fe:	a3 e5       	ldi	r26, 0x53	; 83
 400:	b0 e0       	ldi	r27, 0x00	; 0
 402:	e3 e5       	ldi	r30, 0x53	; 83
 404:	f0 e0       	ldi	r31, 0x00	; 0
 406:	80 81       	ld	r24, Z
 408:	87 7f       	andi	r24, 0xF7	; 247
 40a:	8c 93       	st	X, r24
	/* OC0 Pin disconnected in CTC mode */
	CLR_BIT(TCCR0_REG,5);
 40c:	a3 e5       	ldi	r26, 0x53	; 83
 40e:	b0 e0       	ldi	r27, 0x00	; 0
 410:	e3 e5       	ldi	r30, 0x53	; 83
 412:	f0 e0       	ldi	r31, 0x00	; 0
 414:	80 81       	ld	r24, Z
 416:	8f 7d       	andi	r24, 0xDF	; 223
 418:	8c 93       	st	X, r24
	CLR_BIT(TCCR0_REG,4);
 41a:	a3 e5       	ldi	r26, 0x53	; 83
 41c:	b0 e0       	ldi	r27, 0x00	; 0
 41e:	e3 e5       	ldi	r30, 0x53	; 83
 420:	f0 e0       	ldi	r31, 0x00	; 0
 422:	80 81       	ld	r24, Z
 424:	8f 7e       	andi	r24, 0xEF	; 239
 426:	8c 93       	st	X, r24
	/* Choose clock source: /64 from pre-scalar */
	CLR_BIT(TCCR0_REG,2);
 428:	a3 e5       	ldi	r26, 0x53	; 83
 42a:	b0 e0       	ldi	r27, 0x00	; 0
 42c:	e3 e5       	ldi	r30, 0x53	; 83
 42e:	f0 e0       	ldi	r31, 0x00	; 0
 430:	80 81       	ld	r24, Z
 432:	8b 7f       	andi	r24, 0xFB	; 251
 434:	8c 93       	st	X, r24
	SET_BIT(TCCR0_REG,1);
 436:	a3 e5       	ldi	r26, 0x53	; 83
 438:	b0 e0       	ldi	r27, 0x00	; 0
 43a:	e3 e5       	ldi	r30, 0x53	; 83
 43c:	f0 e0       	ldi	r31, 0x00	; 0
 43e:	80 81       	ld	r24, Z
 440:	82 60       	ori	r24, 0x02	; 2
 442:	8c 93       	st	X, r24
	SET_BIT(TCCR0_REG,0);
 444:	a3 e5       	ldi	r26, 0x53	; 83
 446:	b0 e0       	ldi	r27, 0x00	; 0
 448:	e3 e5       	ldi	r30, 0x53	; 83
 44a:	f0 e0       	ldi	r31, 0x00	; 0
 44c:	80 81       	ld	r24, Z
 44e:	81 60       	ori	r24, 0x01	; 1
 450:	8c 93       	st	X, r24
	/* Set the TOP value to generate an interrupt every 1ms */
	OCR0_REG=125;
 452:	ec e5       	ldi	r30, 0x5C	; 92
 454:	f0 e0       	ldi	r31, 0x00	; 0
 456:	8d e7       	ldi	r24, 0x7D	; 125
 458:	80 83       	st	Z, r24
	/* Enable OCIE0 compare match interrupt enable */
	SET_BIT(TIMSK_REG,1);
 45a:	a9 e5       	ldi	r26, 0x59	; 89
 45c:	b0 e0       	ldi	r27, 0x00	; 0
 45e:	e9 e5       	ldi	r30, 0x59	; 89
 460:	f0 e0       	ldi	r31, 0x00	; 0
 462:	80 81       	ld	r24, Z
 464:	82 60       	ori	r24, 0x02	; 2
 466:	8c 93       	st	X, r24
}
 468:	cf 91       	pop	r28
 46a:	df 91       	pop	r29
 46c:	08 95       	ret

0000046e <MTMR0_CTC_CallbackFunction>:
/************************************************************************************
 * Function: MTMR0_CTC_CallbackFunction
 * Description: Sets a callback function that will be called on Timer0 CTC interrupt.
 ************************************************************************************/
void MTMR0_CTC_CallbackFunction (void (*Copy_ptf)(void))
{
 46e:	df 93       	push	r29
 470:	cf 93       	push	r28
 472:	00 d0       	rcall	.+0      	; 0x474 <MTMR0_CTC_CallbackFunction+0x6>
 474:	cd b7       	in	r28, 0x3d	; 61
 476:	de b7       	in	r29, 0x3e	; 62
 478:	9a 83       	std	Y+2, r25	; 0x02
 47a:	89 83       	std	Y+1, r24	; 0x01
	/* Store the pointer to the callback function */
	GLOB_TMR0CTCCallBackPtr=Copy_ptf;
 47c:	89 81       	ldd	r24, Y+1	; 0x01
 47e:	9a 81       	ldd	r25, Y+2	; 0x02
 480:	90 93 73 00 	sts	0x0073, r25
 484:	80 93 72 00 	sts	0x0072, r24
}
 488:	0f 90       	pop	r0
 48a:	0f 90       	pop	r0
 48c:	cf 91       	pop	r28
 48e:	df 91       	pop	r29
 490:	08 95       	ret

00000492 <MTMR0_VOIDFastPWMInit>:
 *  - Configures the timer mode, clock source, and pre-scaler.
 *  - Sets output compare behavior for Fast PWM mode.
 *  - Disables OCIE0 interrupt.
 ************************************************************************************/
void MTMR0_VOIDFastPWMInit (void)
{
 492:	df 93       	push	r29
 494:	cf 93       	push	r28
 496:	cd b7       	in	r28, 0x3d	; 61
 498:	de b7       	in	r29, 0x3e	; 62
	/* Select Fast PWM Mode: Set WGM00 and WGM01 */
	SET_BIT(TCCR0_REG,6);
 49a:	a3 e5       	ldi	r26, 0x53	; 83
 49c:	b0 e0       	ldi	r27, 0x00	; 0
 49e:	e3 e5       	ldi	r30, 0x53	; 83
 4a0:	f0 e0       	ldi	r31, 0x00	; 0
 4a2:	80 81       	ld	r24, Z
 4a4:	80 64       	ori	r24, 0x40	; 64
 4a6:	8c 93       	st	X, r24
	SET_BIT(TCCR0_REG,3);
 4a8:	a3 e5       	ldi	r26, 0x53	; 83
 4aa:	b0 e0       	ldi	r27, 0x00	; 0
 4ac:	e3 e5       	ldi	r30, 0x53	; 83
 4ae:	f0 e0       	ldi	r31, 0x00	; 0
 4b0:	80 81       	ld	r24, Z
 4b2:	88 60       	ori	r24, 0x08	; 8
 4b4:	8c 93       	st	X, r24
	/* Set OC0 behavior according to Fast PWM mode */
	SET_BIT(TCCR0_REG,5);
 4b6:	a3 e5       	ldi	r26, 0x53	; 83
 4b8:	b0 e0       	ldi	r27, 0x00	; 0
 4ba:	e3 e5       	ldi	r30, 0x53	; 83
 4bc:	f0 e0       	ldi	r31, 0x00	; 0
 4be:	80 81       	ld	r24, Z
 4c0:	80 62       	ori	r24, 0x20	; 32
 4c2:	8c 93       	st	X, r24
	CLR_BIT(TCCR0_REG,4);
 4c4:	a3 e5       	ldi	r26, 0x53	; 83
 4c6:	b0 e0       	ldi	r27, 0x00	; 0
 4c8:	e3 e5       	ldi	r30, 0x53	; 83
 4ca:	f0 e0       	ldi	r31, 0x00	; 0
 4cc:	80 81       	ld	r24, Z
 4ce:	8f 7e       	andi	r24, 0xEF	; 239
 4d0:	8c 93       	st	X, r24
	/* Choose clock source: /256 from pre-scalar --> Frequency = 3906.25Hz */
	SET_BIT(TCCR0_REG,2);
 4d2:	a3 e5       	ldi	r26, 0x53	; 83
 4d4:	b0 e0       	ldi	r27, 0x00	; 0
 4d6:	e3 e5       	ldi	r30, 0x53	; 83
 4d8:	f0 e0       	ldi	r31, 0x00	; 0
 4da:	80 81       	ld	r24, Z
 4dc:	84 60       	ori	r24, 0x04	; 4
 4de:	8c 93       	st	X, r24
	CLR_BIT(TCCR0_REG,1);
 4e0:	a3 e5       	ldi	r26, 0x53	; 83
 4e2:	b0 e0       	ldi	r27, 0x00	; 0
 4e4:	e3 e5       	ldi	r30, 0x53	; 83
 4e6:	f0 e0       	ldi	r31, 0x00	; 0
 4e8:	80 81       	ld	r24, Z
 4ea:	8d 7f       	andi	r24, 0xFD	; 253
 4ec:	8c 93       	st	X, r24
	CLR_BIT(TCCR0_REG,0);
 4ee:	a3 e5       	ldi	r26, 0x53	; 83
 4f0:	b0 e0       	ldi	r27, 0x00	; 0
 4f2:	e3 e5       	ldi	r30, 0x53	; 83
 4f4:	f0 e0       	ldi	r31, 0x00	; 0
 4f6:	80 81       	ld	r24, Z
 4f8:	8e 7f       	andi	r24, 0xFE	; 254
 4fa:	8c 93       	st	X, r24
	/* Disable OCIE0 interrupt */
	CLR_BIT(TIMSK_REG,1);
 4fc:	a9 e5       	ldi	r26, 0x59	; 89
 4fe:	b0 e0       	ldi	r27, 0x00	; 0
 500:	e9 e5       	ldi	r30, 0x59	; 89
 502:	f0 e0       	ldi	r31, 0x00	; 0
 504:	80 81       	ld	r24, Z
 506:	8d 7f       	andi	r24, 0xFD	; 253
 508:	8c 93       	st	X, r24
}
 50a:	cf 91       	pop	r28
 50c:	df 91       	pop	r29
 50e:	08 95       	ret

00000510 <MTMR0_VOIDSetDutyCycle>:
 * Description: Sets the duty cycle for Timer0 in Fast PWM mode.
 *  - Duty cycle is provided as a percentage (0-100).
 *  - The duty cycle is mapped to the OCR0 register for PWM generation.
 ************************************************************************************/
void MTMR0_VOIDSetDutyCycle (u8 Copy_U8DutyCycle)
{
 510:	df 93       	push	r29
 512:	cf 93       	push	r28
 514:	0f 92       	push	r0
 516:	cd b7       	in	r28, 0x3d	; 61
 518:	de b7       	in	r29, 0x3e	; 62
 51a:	89 83       	std	Y+1, r24	; 0x01
	/* Set the OCR0 value to achieve the desired duty cycle */
	OCR0_REG= (Copy_U8DutyCycle*255)/100 ;
 51c:	ec e5       	ldi	r30, 0x5C	; 92
 51e:	f0 e0       	ldi	r31, 0x00	; 0
 520:	89 81       	ldd	r24, Y+1	; 0x01
 522:	48 2f       	mov	r20, r24
 524:	50 e0       	ldi	r21, 0x00	; 0
 526:	ca 01       	movw	r24, r20
 528:	9c 01       	movw	r18, r24
 52a:	22 0f       	add	r18, r18
 52c:	33 1f       	adc	r19, r19
 52e:	c9 01       	movw	r24, r18
 530:	96 95       	lsr	r25
 532:	98 2f       	mov	r25, r24
 534:	88 27       	eor	r24, r24
 536:	97 95       	ror	r25
 538:	87 95       	ror	r24
 53a:	82 1b       	sub	r24, r18
 53c:	93 0b       	sbc	r25, r19
 53e:	84 0f       	add	r24, r20
 540:	95 1f       	adc	r25, r21
 542:	24 e6       	ldi	r18, 0x64	; 100
 544:	30 e0       	ldi	r19, 0x00	; 0
 546:	b9 01       	movw	r22, r18
 548:	0e 94 ce 07 	call	0xf9c	; 0xf9c <__divmodhi4>
 54c:	cb 01       	movw	r24, r22
 54e:	80 83       	st	Z, r24
}
 550:	0f 90       	pop	r0
 552:	cf 91       	pop	r28
 554:	df 91       	pop	r29
 556:	08 95       	ret

00000558 <MTMR1_VOIDOVInitialization>:
 * Description: Initializes Timer1 in Normal mode for overflow interrupt.
 *  - Configures the timer mode, clock source, and pre-scaler.
 *  - Enables the overflow interrupt for Timer1.
 ************************************************************************************/
void MTMR1_VOIDOVInitialization (void)
{
 558:	df 93       	push	r29
 55a:	cf 93       	push	r28
 55c:	cd b7       	in	r28, 0x3d	; 61
 55e:	de b7       	in	r29, 0x3e	; 62
	/* Select Normal Mode: Clear WGM10, WGM11, WGM12, and WGM13 */
	CLR_BIT(TCCR1A_REG,1);
 560:	af e4       	ldi	r26, 0x4F	; 79
 562:	b0 e0       	ldi	r27, 0x00	; 0
 564:	ef e4       	ldi	r30, 0x4F	; 79
 566:	f0 e0       	ldi	r31, 0x00	; 0
 568:	80 81       	ld	r24, Z
 56a:	8d 7f       	andi	r24, 0xFD	; 253
 56c:	8c 93       	st	X, r24
	CLR_BIT(TCCR1A_REG,0);
 56e:	af e4       	ldi	r26, 0x4F	; 79
 570:	b0 e0       	ldi	r27, 0x00	; 0
 572:	ef e4       	ldi	r30, 0x4F	; 79
 574:	f0 e0       	ldi	r31, 0x00	; 0
 576:	80 81       	ld	r24, Z
 578:	8e 7f       	andi	r24, 0xFE	; 254
 57a:	8c 93       	st	X, r24
	CLR_BIT(TCCR1B_REG,4);
 57c:	ae e4       	ldi	r26, 0x4E	; 78
 57e:	b0 e0       	ldi	r27, 0x00	; 0
 580:	ee e4       	ldi	r30, 0x4E	; 78
 582:	f0 e0       	ldi	r31, 0x00	; 0
 584:	80 81       	ld	r24, Z
 586:	8f 7e       	andi	r24, 0xEF	; 239
 588:	8c 93       	st	X, r24
	CLR_BIT(TCCR1B_REG,3);
 58a:	ae e4       	ldi	r26, 0x4E	; 78
 58c:	b0 e0       	ldi	r27, 0x00	; 0
 58e:	ee e4       	ldi	r30, 0x4E	; 78
 590:	f0 e0       	ldi	r31, 0x00	; 0
 592:	80 81       	ld	r24, Z
 594:	87 7f       	andi	r24, 0xF7	; 247
 596:	8c 93       	st	X, r24
	/* Compare match output behavior depends on normal mode */
	CLR_BIT(TCCR1A_REG,7);
 598:	af e4       	ldi	r26, 0x4F	; 79
 59a:	b0 e0       	ldi	r27, 0x00	; 0
 59c:	ef e4       	ldi	r30, 0x4F	; 79
 59e:	f0 e0       	ldi	r31, 0x00	; 0
 5a0:	80 81       	ld	r24, Z
 5a2:	8f 77       	andi	r24, 0x7F	; 127
 5a4:	8c 93       	st	X, r24
	CLR_BIT(TCCR1A_REG,6);
 5a6:	af e4       	ldi	r26, 0x4F	; 79
 5a8:	b0 e0       	ldi	r27, 0x00	; 0
 5aa:	ef e4       	ldi	r30, 0x4F	; 79
 5ac:	f0 e0       	ldi	r31, 0x00	; 0
 5ae:	80 81       	ld	r24, Z
 5b0:	8f 7b       	andi	r24, 0xBF	; 191
 5b2:	8c 93       	st	X, r24
	CLR_BIT(TCCR1A_REG,5);
 5b4:	af e4       	ldi	r26, 0x4F	; 79
 5b6:	b0 e0       	ldi	r27, 0x00	; 0
 5b8:	ef e4       	ldi	r30, 0x4F	; 79
 5ba:	f0 e0       	ldi	r31, 0x00	; 0
 5bc:	80 81       	ld	r24, Z
 5be:	8f 7d       	andi	r24, 0xDF	; 223
 5c0:	8c 93       	st	X, r24
	CLR_BIT(TCCR1A_REG,4);
 5c2:	af e4       	ldi	r26, 0x4F	; 79
 5c4:	b0 e0       	ldi	r27, 0x00	; 0
 5c6:	ef e4       	ldi	r30, 0x4F	; 79
 5c8:	f0 e0       	ldi	r31, 0x00	; 0
 5ca:	80 81       	ld	r24, Z
 5cc:	8f 7e       	andi	r24, 0xEF	; 239
 5ce:	8c 93       	st	X, r24
	/* Choose clock source: /256 from pre-scalar */
	SET_BIT(TCCR1B_REG,2);
 5d0:	ae e4       	ldi	r26, 0x4E	; 78
 5d2:	b0 e0       	ldi	r27, 0x00	; 0
 5d4:	ee e4       	ldi	r30, 0x4E	; 78
 5d6:	f0 e0       	ldi	r31, 0x00	; 0
 5d8:	80 81       	ld	r24, Z
 5da:	84 60       	ori	r24, 0x04	; 4
 5dc:	8c 93       	st	X, r24
	CLR_BIT(TCCR1B_REG,1);
 5de:	ae e4       	ldi	r26, 0x4E	; 78
 5e0:	b0 e0       	ldi	r27, 0x00	; 0
 5e2:	ee e4       	ldi	r30, 0x4E	; 78
 5e4:	f0 e0       	ldi	r31, 0x00	; 0
 5e6:	80 81       	ld	r24, Z
 5e8:	8d 7f       	andi	r24, 0xFD	; 253
 5ea:	8c 93       	st	X, r24
	CLR_BIT(TCCR1B_REG,0);
 5ec:	ae e4       	ldi	r26, 0x4E	; 78
 5ee:	b0 e0       	ldi	r27, 0x00	; 0
 5f0:	ee e4       	ldi	r30, 0x4E	; 78
 5f2:	f0 e0       	ldi	r31, 0x00	; 0
 5f4:	80 81       	ld	r24, Z
 5f6:	8e 7f       	andi	r24, 0xFE	; 254
 5f8:	8c 93       	st	X, r24
	/* Enable TOIE0 overflow interrupt enable */
	SET_BIT(TIMSK_REG,0);
 5fa:	a9 e5       	ldi	r26, 0x59	; 89
 5fc:	b0 e0       	ldi	r27, 0x00	; 0
 5fe:	e9 e5       	ldi	r30, 0x59	; 89
 600:	f0 e0       	ldi	r31, 0x00	; 0
 602:	80 81       	ld	r24, Z
 604:	81 60       	ori	r24, 0x01	; 1
 606:	8c 93       	st	X, r24
}
 608:	cf 91       	pop	r28
 60a:	df 91       	pop	r29
 60c:	08 95       	ret

0000060e <__vector_11>:
/************************************************************************************
 * Interrupt Service Routine for Timer0 Overflow Interrupt.
 *  - Toggles Pin 0 of Port A every 31 overflows.
 ************************************************************************************/
void __vector_11 (void)
{
 60e:	1f 92       	push	r1
 610:	0f 92       	push	r0
 612:	0f b6       	in	r0, 0x3f	; 63
 614:	0f 92       	push	r0
 616:	11 24       	eor	r1, r1
 618:	2f 93       	push	r18
 61a:	3f 93       	push	r19
 61c:	4f 93       	push	r20
 61e:	5f 93       	push	r21
 620:	6f 93       	push	r22
 622:	7f 93       	push	r23
 624:	8f 93       	push	r24
 626:	9f 93       	push	r25
 628:	af 93       	push	r26
 62a:	bf 93       	push	r27
 62c:	ef 93       	push	r30
 62e:	ff 93       	push	r31
 630:	df 93       	push	r29
 632:	cf 93       	push	r28
 634:	cd b7       	in	r28, 0x3d	; 61
 636:	de b7       	in	r29, 0x3e	; 62
	static u8 counter=0;
	counter++;
 638:	80 91 71 00 	lds	r24, 0x0071
 63c:	8f 5f       	subi	r24, 0xFF	; 255
 63e:	80 93 71 00 	sts	0x0071, r24
	/* Every 31 overflows, reset the counter and toggle the pin */
	if(counter == 31)
 642:	80 91 71 00 	lds	r24, 0x0071
 646:	8f 31       	cpi	r24, 0x1F	; 31
 648:	51 f4       	brne	.+20     	; 0x65e <__vector_11+0x50>
	{
		TCNT0_REG=123;      /* Reset Timer0 counter */
 64a:	e2 e5       	ldi	r30, 0x52	; 82
 64c:	f0 e0       	ldi	r31, 0x00	; 0
 64e:	8b e7       	ldi	r24, 0x7B	; 123
 650:	80 83       	st	Z, r24
		MDIO_VOIDTogglePinValue(0,0); /* Toggle Pin 0 of Port A */
 652:	80 e0       	ldi	r24, 0x00	; 0
 654:	60 e0       	ldi	r22, 0x00	; 0
 656:	0e 94 45 06 	call	0xc8a	; 0xc8a <MDIO_VOIDTogglePinValue>
		counter=0;          /* Reset counter */
 65a:	10 92 71 00 	sts	0x0071, r1
	}
}
 65e:	cf 91       	pop	r28
 660:	df 91       	pop	r29
 662:	ff 91       	pop	r31
 664:	ef 91       	pop	r30
 666:	bf 91       	pop	r27
 668:	af 91       	pop	r26
 66a:	9f 91       	pop	r25
 66c:	8f 91       	pop	r24
 66e:	7f 91       	pop	r23
 670:	6f 91       	pop	r22
 672:	5f 91       	pop	r21
 674:	4f 91       	pop	r20
 676:	3f 91       	pop	r19
 678:	2f 91       	pop	r18
 67a:	0f 90       	pop	r0
 67c:	0f be       	out	0x3f, r0	; 63
 67e:	0f 90       	pop	r0
 680:	1f 90       	pop	r1
 682:	18 95       	reti

00000684 <__vector_10>:
/************************************************************************************
 * Interrupt Service Routine for Timer0 CTC Interrupt.
 *  - Calls the user-defined callback function if set.
 ************************************************************************************/
void __vector_10 (void)
{
 684:	1f 92       	push	r1
 686:	0f 92       	push	r0
 688:	0f b6       	in	r0, 0x3f	; 63
 68a:	0f 92       	push	r0
 68c:	11 24       	eor	r1, r1
 68e:	2f 93       	push	r18
 690:	3f 93       	push	r19
 692:	4f 93       	push	r20
 694:	5f 93       	push	r21
 696:	6f 93       	push	r22
 698:	7f 93       	push	r23
 69a:	8f 93       	push	r24
 69c:	9f 93       	push	r25
 69e:	af 93       	push	r26
 6a0:	bf 93       	push	r27
 6a2:	ef 93       	push	r30
 6a4:	ff 93       	push	r31
 6a6:	df 93       	push	r29
 6a8:	cf 93       	push	r28
 6aa:	cd b7       	in	r28, 0x3d	; 61
 6ac:	de b7       	in	r29, 0x3e	; 62
	/* Call the callback function set by the user */
	GLOB_TMR0CTCCallBackPtr();
 6ae:	e0 91 72 00 	lds	r30, 0x0072
 6b2:	f0 91 73 00 	lds	r31, 0x0073
 6b6:	09 95       	icall
}
 6b8:	cf 91       	pop	r28
 6ba:	df 91       	pop	r29
 6bc:	ff 91       	pop	r31
 6be:	ef 91       	pop	r30
 6c0:	bf 91       	pop	r27
 6c2:	af 91       	pop	r26
 6c4:	9f 91       	pop	r25
 6c6:	8f 91       	pop	r24
 6c8:	7f 91       	pop	r23
 6ca:	6f 91       	pop	r22
 6cc:	5f 91       	pop	r21
 6ce:	4f 91       	pop	r20
 6d0:	3f 91       	pop	r19
 6d2:	2f 91       	pop	r18
 6d4:	0f 90       	pop	r0
 6d6:	0f be       	out	0x3f, r0	; 63
 6d8:	0f 90       	pop	r0
 6da:	1f 90       	pop	r1
 6dc:	18 95       	reti

000006de <MGIE_VOIDEnable>:
 * Parameters: None
 * Return: None
 * Usage: Call this function to enable interrupts globally in the system.
 ************************************************************************************/
void MGIE_VOIDEnable(void)
{
 6de:	df 93       	push	r29
 6e0:	cf 93       	push	r28
 6e2:	cd b7       	in	r28, 0x3d	; 61
 6e4:	de b7       	in	r29, 0x3e	; 62
    /* Set the I bit (bit 7) of the SREG register to 1 to enable interrupts */
    SET_BIT(SREG_REG, 7);
 6e6:	af e5       	ldi	r26, 0x5F	; 95
 6e8:	b0 e0       	ldi	r27, 0x00	; 0
 6ea:	ef e5       	ldi	r30, 0x5F	; 95
 6ec:	f0 e0       	ldi	r31, 0x00	; 0
 6ee:	80 81       	ld	r24, Z
 6f0:	80 68       	ori	r24, 0x80	; 128
 6f2:	8c 93       	st	X, r24
}
 6f4:	cf 91       	pop	r28
 6f6:	df 91       	pop	r29
 6f8:	08 95       	ret

000006fa <MGIE_VOIDDisable>:
 * Parameters: None
 * Return: None
 * Usage: Call this function to disable interrupts globally in the system.
 ************************************************************************************/
void MGIE_VOIDDisable(void)
{
 6fa:	df 93       	push	r29
 6fc:	cf 93       	push	r28
 6fe:	cd b7       	in	r28, 0x3d	; 61
 700:	de b7       	in	r29, 0x3e	; 62
    /* Clear the I bit (bit 7) of the SREG register to disable interrupts */
    CLR_BIT(SREG_REG, 7);
 702:	af e5       	ldi	r26, 0x5F	; 95
 704:	b0 e0       	ldi	r27, 0x00	; 0
 706:	ef e5       	ldi	r30, 0x5F	; 95
 708:	f0 e0       	ldi	r31, 0x00	; 0
 70a:	80 81       	ld	r24, Z
 70c:	8f 77       	andi	r24, 0x7F	; 127
 70e:	8c 93       	st	X, r24
}
 710:	cf 91       	pop	r28
 712:	df 91       	pop	r29
 714:	08 95       	ret

00000716 <MDIO_VOIDSetPinDirection>:
 *      - Copy_U8Pin: The pin number (0 to 7)
 *      - Copy_U8Direction: The direction (1 for output, 0 for input)
 * Return: None
 ************************************************************************************/
void MDIO_VOIDSetPinDirection(u8 Copy_U8Port, u8 Copy_U8Pin, u8 Copy_U8Direction)
{
 716:	df 93       	push	r29
 718:	cf 93       	push	r28
 71a:	cd b7       	in	r28, 0x3d	; 61
 71c:	de b7       	in	r29, 0x3e	; 62
 71e:	27 97       	sbiw	r28, 0x07	; 7
 720:	0f b6       	in	r0, 0x3f	; 63
 722:	f8 94       	cli
 724:	de bf       	out	0x3e, r29	; 62
 726:	0f be       	out	0x3f, r0	; 63
 728:	cd bf       	out	0x3d, r28	; 61
 72a:	89 83       	std	Y+1, r24	; 0x01
 72c:	6a 83       	std	Y+2, r22	; 0x02
 72e:	4b 83       	std	Y+3, r20	; 0x03
	/* Check if the desired direction is output (1) */
	if (1 == Copy_U8Direction)
 730:	8b 81       	ldd	r24, Y+3	; 0x03
 732:	81 30       	cpi	r24, 0x01	; 1
 734:	09 f0       	breq	.+2      	; 0x738 <MDIO_VOIDSetPinDirection+0x22>
 736:	6f c0       	rjmp	.+222    	; 0x816 <MDIO_VOIDSetPinDirection+0x100>
	{
		/* Use the switch statement to handle different ports */
		switch (Copy_U8Port)
 738:	89 81       	ldd	r24, Y+1	; 0x01
 73a:	28 2f       	mov	r18, r24
 73c:	30 e0       	ldi	r19, 0x00	; 0
 73e:	3f 83       	std	Y+7, r19	; 0x07
 740:	2e 83       	std	Y+6, r18	; 0x06
 742:	8e 81       	ldd	r24, Y+6	; 0x06
 744:	9f 81       	ldd	r25, Y+7	; 0x07
 746:	81 30       	cpi	r24, 0x01	; 1
 748:	91 05       	cpc	r25, r1
 74a:	49 f1       	breq	.+82     	; 0x79e <MDIO_VOIDSetPinDirection+0x88>
 74c:	2e 81       	ldd	r18, Y+6	; 0x06
 74e:	3f 81       	ldd	r19, Y+7	; 0x07
 750:	22 30       	cpi	r18, 0x02	; 2
 752:	31 05       	cpc	r19, r1
 754:	2c f4       	brge	.+10     	; 0x760 <MDIO_VOIDSetPinDirection+0x4a>
 756:	8e 81       	ldd	r24, Y+6	; 0x06
 758:	9f 81       	ldd	r25, Y+7	; 0x07
 75a:	00 97       	sbiw	r24, 0x00	; 0
 75c:	61 f0       	breq	.+24     	; 0x776 <MDIO_VOIDSetPinDirection+0x60>
 75e:	d2 c0       	rjmp	.+420    	; 0x904 <__stack+0xa5>
 760:	2e 81       	ldd	r18, Y+6	; 0x06
 762:	3f 81       	ldd	r19, Y+7	; 0x07
 764:	22 30       	cpi	r18, 0x02	; 2
 766:	31 05       	cpc	r19, r1
 768:	71 f1       	breq	.+92     	; 0x7c6 <MDIO_VOIDSetPinDirection+0xb0>
 76a:	8e 81       	ldd	r24, Y+6	; 0x06
 76c:	9f 81       	ldd	r25, Y+7	; 0x07
 76e:	83 30       	cpi	r24, 0x03	; 3
 770:	91 05       	cpc	r25, r1
 772:	e9 f1       	breq	.+122    	; 0x7ee <MDIO_VOIDSetPinDirection+0xd8>
 774:	c7 c0       	rjmp	.+398    	; 0x904 <__stack+0xa5>
		{
		case 0:
			/* Set the corresponding bit in DDRA register to configure as output */
			SET_BIT(DDRA_REG, Copy_U8Pin);
 776:	aa e3       	ldi	r26, 0x3A	; 58
 778:	b0 e0       	ldi	r27, 0x00	; 0
 77a:	ea e3       	ldi	r30, 0x3A	; 58
 77c:	f0 e0       	ldi	r31, 0x00	; 0
 77e:	80 81       	ld	r24, Z
 780:	48 2f       	mov	r20, r24
 782:	8a 81       	ldd	r24, Y+2	; 0x02
 784:	28 2f       	mov	r18, r24
 786:	30 e0       	ldi	r19, 0x00	; 0
 788:	81 e0       	ldi	r24, 0x01	; 1
 78a:	90 e0       	ldi	r25, 0x00	; 0
 78c:	02 2e       	mov	r0, r18
 78e:	02 c0       	rjmp	.+4      	; 0x794 <MDIO_VOIDSetPinDirection+0x7e>
 790:	88 0f       	add	r24, r24
 792:	99 1f       	adc	r25, r25
 794:	0a 94       	dec	r0
 796:	e2 f7       	brpl	.-8      	; 0x790 <MDIO_VOIDSetPinDirection+0x7a>
 798:	84 2b       	or	r24, r20
 79a:	8c 93       	st	X, r24
 79c:	b3 c0       	rjmp	.+358    	; 0x904 <__stack+0xa5>
			break;
		case 1:
			/* Set the corresponding bit in DDRB register to configure as output */
			SET_BIT(DDRB_REG, Copy_U8Pin);
 79e:	a7 e3       	ldi	r26, 0x37	; 55
 7a0:	b0 e0       	ldi	r27, 0x00	; 0
 7a2:	e7 e3       	ldi	r30, 0x37	; 55
 7a4:	f0 e0       	ldi	r31, 0x00	; 0
 7a6:	80 81       	ld	r24, Z
 7a8:	48 2f       	mov	r20, r24
 7aa:	8a 81       	ldd	r24, Y+2	; 0x02
 7ac:	28 2f       	mov	r18, r24
 7ae:	30 e0       	ldi	r19, 0x00	; 0
 7b0:	81 e0       	ldi	r24, 0x01	; 1
 7b2:	90 e0       	ldi	r25, 0x00	; 0
 7b4:	02 2e       	mov	r0, r18
 7b6:	02 c0       	rjmp	.+4      	; 0x7bc <MDIO_VOIDSetPinDirection+0xa6>
 7b8:	88 0f       	add	r24, r24
 7ba:	99 1f       	adc	r25, r25
 7bc:	0a 94       	dec	r0
 7be:	e2 f7       	brpl	.-8      	; 0x7b8 <MDIO_VOIDSetPinDirection+0xa2>
 7c0:	84 2b       	or	r24, r20
 7c2:	8c 93       	st	X, r24
 7c4:	9f c0       	rjmp	.+318    	; 0x904 <__stack+0xa5>
			break;
		case 2:
			/* Set the corresponding bit in DDRC register to configure as output */
			SET_BIT(DDRC_REG, Copy_U8Pin);
 7c6:	a4 e3       	ldi	r26, 0x34	; 52
 7c8:	b0 e0       	ldi	r27, 0x00	; 0
 7ca:	e4 e3       	ldi	r30, 0x34	; 52
 7cc:	f0 e0       	ldi	r31, 0x00	; 0
 7ce:	80 81       	ld	r24, Z
 7d0:	48 2f       	mov	r20, r24
 7d2:	8a 81       	ldd	r24, Y+2	; 0x02
 7d4:	28 2f       	mov	r18, r24
 7d6:	30 e0       	ldi	r19, 0x00	; 0
 7d8:	81 e0       	ldi	r24, 0x01	; 1
 7da:	90 e0       	ldi	r25, 0x00	; 0
 7dc:	02 2e       	mov	r0, r18
 7de:	02 c0       	rjmp	.+4      	; 0x7e4 <MDIO_VOIDSetPinDirection+0xce>
 7e0:	88 0f       	add	r24, r24
 7e2:	99 1f       	adc	r25, r25
 7e4:	0a 94       	dec	r0
 7e6:	e2 f7       	brpl	.-8      	; 0x7e0 <MDIO_VOIDSetPinDirection+0xca>
 7e8:	84 2b       	or	r24, r20
 7ea:	8c 93       	st	X, r24
 7ec:	8b c0       	rjmp	.+278    	; 0x904 <__stack+0xa5>
			break;
		case 3:
			/* Set the corresponding bit in DDRD register to configure as output */
			SET_BIT(DDRD_REG, Copy_U8Pin);
 7ee:	a1 e3       	ldi	r26, 0x31	; 49
 7f0:	b0 e0       	ldi	r27, 0x00	; 0
 7f2:	e1 e3       	ldi	r30, 0x31	; 49
 7f4:	f0 e0       	ldi	r31, 0x00	; 0
 7f6:	80 81       	ld	r24, Z
 7f8:	48 2f       	mov	r20, r24
 7fa:	8a 81       	ldd	r24, Y+2	; 0x02
 7fc:	28 2f       	mov	r18, r24
 7fe:	30 e0       	ldi	r19, 0x00	; 0
 800:	81 e0       	ldi	r24, 0x01	; 1
 802:	90 e0       	ldi	r25, 0x00	; 0
 804:	02 2e       	mov	r0, r18
 806:	02 c0       	rjmp	.+4      	; 0x80c <MDIO_VOIDSetPinDirection+0xf6>
 808:	88 0f       	add	r24, r24
 80a:	99 1f       	adc	r25, r25
 80c:	0a 94       	dec	r0
 80e:	e2 f7       	brpl	.-8      	; 0x808 <MDIO_VOIDSetPinDirection+0xf2>
 810:	84 2b       	or	r24, r20
 812:	8c 93       	st	X, r24
 814:	77 c0       	rjmp	.+238    	; 0x904 <__stack+0xa5>
			/* Invalid port, do nothing */
			break;
		}
	}
	/* Check if the desired direction is input (0) */
	else if (0 == Copy_U8Direction)
 816:	8b 81       	ldd	r24, Y+3	; 0x03
 818:	88 23       	and	r24, r24
 81a:	09 f0       	breq	.+2      	; 0x81e <MDIO_VOIDSetPinDirection+0x108>
 81c:	73 c0       	rjmp	.+230    	; 0x904 <__stack+0xa5>
	{
		/* Use the switch statement to handle different ports */
		switch (Copy_U8Port)
 81e:	89 81       	ldd	r24, Y+1	; 0x01
 820:	28 2f       	mov	r18, r24
 822:	30 e0       	ldi	r19, 0x00	; 0
 824:	3d 83       	std	Y+5, r19	; 0x05
 826:	2c 83       	std	Y+4, r18	; 0x04
 828:	8c 81       	ldd	r24, Y+4	; 0x04
 82a:	9d 81       	ldd	r25, Y+5	; 0x05
 82c:	81 30       	cpi	r24, 0x01	; 1
 82e:	91 05       	cpc	r25, r1
 830:	59 f1       	breq	.+86     	; 0x888 <__stack+0x29>
 832:	2c 81       	ldd	r18, Y+4	; 0x04
 834:	3d 81       	ldd	r19, Y+5	; 0x05
 836:	22 30       	cpi	r18, 0x02	; 2
 838:	31 05       	cpc	r19, r1
 83a:	2c f4       	brge	.+10     	; 0x846 <MDIO_VOIDSetPinDirection+0x130>
 83c:	8c 81       	ldd	r24, Y+4	; 0x04
 83e:	9d 81       	ldd	r25, Y+5	; 0x05
 840:	00 97       	sbiw	r24, 0x00	; 0
 842:	69 f0       	breq	.+26     	; 0x85e <MDIO_VOIDSetPinDirection+0x148>
 844:	5f c0       	rjmp	.+190    	; 0x904 <__stack+0xa5>
 846:	2c 81       	ldd	r18, Y+4	; 0x04
 848:	3d 81       	ldd	r19, Y+5	; 0x05
 84a:	22 30       	cpi	r18, 0x02	; 2
 84c:	31 05       	cpc	r19, r1
 84e:	89 f1       	breq	.+98     	; 0x8b2 <__stack+0x53>
 850:	8c 81       	ldd	r24, Y+4	; 0x04
 852:	9d 81       	ldd	r25, Y+5	; 0x05
 854:	83 30       	cpi	r24, 0x03	; 3
 856:	91 05       	cpc	r25, r1
 858:	09 f4       	brne	.+2      	; 0x85c <MDIO_VOIDSetPinDirection+0x146>
 85a:	40 c0       	rjmp	.+128    	; 0x8dc <__stack+0x7d>
 85c:	53 c0       	rjmp	.+166    	; 0x904 <__stack+0xa5>
		{
		case 0:
			/* Clear the corresponding bit in DDRA register to configure as input */
			CLR_BIT(DDRA_REG, Copy_U8Pin);
 85e:	aa e3       	ldi	r26, 0x3A	; 58
 860:	b0 e0       	ldi	r27, 0x00	; 0
 862:	ea e3       	ldi	r30, 0x3A	; 58
 864:	f0 e0       	ldi	r31, 0x00	; 0
 866:	80 81       	ld	r24, Z
 868:	48 2f       	mov	r20, r24
 86a:	8a 81       	ldd	r24, Y+2	; 0x02
 86c:	28 2f       	mov	r18, r24
 86e:	30 e0       	ldi	r19, 0x00	; 0
 870:	81 e0       	ldi	r24, 0x01	; 1
 872:	90 e0       	ldi	r25, 0x00	; 0
 874:	02 2e       	mov	r0, r18
 876:	02 c0       	rjmp	.+4      	; 0x87c <__stack+0x1d>
 878:	88 0f       	add	r24, r24
 87a:	99 1f       	adc	r25, r25
 87c:	0a 94       	dec	r0
 87e:	e2 f7       	brpl	.-8      	; 0x878 <__stack+0x19>
 880:	80 95       	com	r24
 882:	84 23       	and	r24, r20
 884:	8c 93       	st	X, r24
 886:	3e c0       	rjmp	.+124    	; 0x904 <__stack+0xa5>
			break;
		case 1:
			/* Clear the corresponding bit in DDRB register to configure as input */
			CLR_BIT(DDRB_REG, Copy_U8Pin);
 888:	a7 e3       	ldi	r26, 0x37	; 55
 88a:	b0 e0       	ldi	r27, 0x00	; 0
 88c:	e7 e3       	ldi	r30, 0x37	; 55
 88e:	f0 e0       	ldi	r31, 0x00	; 0
 890:	80 81       	ld	r24, Z
 892:	48 2f       	mov	r20, r24
 894:	8a 81       	ldd	r24, Y+2	; 0x02
 896:	28 2f       	mov	r18, r24
 898:	30 e0       	ldi	r19, 0x00	; 0
 89a:	81 e0       	ldi	r24, 0x01	; 1
 89c:	90 e0       	ldi	r25, 0x00	; 0
 89e:	02 2e       	mov	r0, r18
 8a0:	02 c0       	rjmp	.+4      	; 0x8a6 <__stack+0x47>
 8a2:	88 0f       	add	r24, r24
 8a4:	99 1f       	adc	r25, r25
 8a6:	0a 94       	dec	r0
 8a8:	e2 f7       	brpl	.-8      	; 0x8a2 <__stack+0x43>
 8aa:	80 95       	com	r24
 8ac:	84 23       	and	r24, r20
 8ae:	8c 93       	st	X, r24
 8b0:	29 c0       	rjmp	.+82     	; 0x904 <__stack+0xa5>
			break;
		case 2:
			/* Clear the corresponding bit in DDRC register to configure as input */
			CLR_BIT(DDRC_REG, Copy_U8Pin);
 8b2:	a4 e3       	ldi	r26, 0x34	; 52
 8b4:	b0 e0       	ldi	r27, 0x00	; 0
 8b6:	e4 e3       	ldi	r30, 0x34	; 52
 8b8:	f0 e0       	ldi	r31, 0x00	; 0
 8ba:	80 81       	ld	r24, Z
 8bc:	48 2f       	mov	r20, r24
 8be:	8a 81       	ldd	r24, Y+2	; 0x02
 8c0:	28 2f       	mov	r18, r24
 8c2:	30 e0       	ldi	r19, 0x00	; 0
 8c4:	81 e0       	ldi	r24, 0x01	; 1
 8c6:	90 e0       	ldi	r25, 0x00	; 0
 8c8:	02 2e       	mov	r0, r18
 8ca:	02 c0       	rjmp	.+4      	; 0x8d0 <__stack+0x71>
 8cc:	88 0f       	add	r24, r24
 8ce:	99 1f       	adc	r25, r25
 8d0:	0a 94       	dec	r0
 8d2:	e2 f7       	brpl	.-8      	; 0x8cc <__stack+0x6d>
 8d4:	80 95       	com	r24
 8d6:	84 23       	and	r24, r20
 8d8:	8c 93       	st	X, r24
 8da:	14 c0       	rjmp	.+40     	; 0x904 <__stack+0xa5>
			break;
		case 3:
			/* Clear the corresponding bit in DDRD register to configure as input */
			CLR_BIT(DDRD_REG, Copy_U8Pin);
 8dc:	a1 e3       	ldi	r26, 0x31	; 49
 8de:	b0 e0       	ldi	r27, 0x00	; 0
 8e0:	e1 e3       	ldi	r30, 0x31	; 49
 8e2:	f0 e0       	ldi	r31, 0x00	; 0
 8e4:	80 81       	ld	r24, Z
 8e6:	48 2f       	mov	r20, r24
 8e8:	8a 81       	ldd	r24, Y+2	; 0x02
 8ea:	28 2f       	mov	r18, r24
 8ec:	30 e0       	ldi	r19, 0x00	; 0
 8ee:	81 e0       	ldi	r24, 0x01	; 1
 8f0:	90 e0       	ldi	r25, 0x00	; 0
 8f2:	02 2e       	mov	r0, r18
 8f4:	02 c0       	rjmp	.+4      	; 0x8fa <__stack+0x9b>
 8f6:	88 0f       	add	r24, r24
 8f8:	99 1f       	adc	r25, r25
 8fa:	0a 94       	dec	r0
 8fc:	e2 f7       	brpl	.-8      	; 0x8f6 <__stack+0x97>
 8fe:	80 95       	com	r24
 900:	84 23       	and	r24, r20
 902:	8c 93       	st	X, r24
	}
	else
	{
		/* Invalid direction value, do nothing */
	}
}
 904:	27 96       	adiw	r28, 0x07	; 7
 906:	0f b6       	in	r0, 0x3f	; 63
 908:	f8 94       	cli
 90a:	de bf       	out	0x3e, r29	; 62
 90c:	0f be       	out	0x3f, r0	; 63
 90e:	cd bf       	out	0x3d, r28	; 61
 910:	cf 91       	pop	r28
 912:	df 91       	pop	r29
 914:	08 95       	ret

00000916 <MDIO_U8GetPinValue>:
 *      - Copy_U8Port: The port number (0 to 3)
 *      - Copy_U8Pin: The pin number (0 to 7)
 * Return: The value of the pin (0 or 1)
 ************************************************************************************/
u8 MDIO_U8GetPinValue(u8 Copy_U8Port, u8 Copy_U8Pin)
{
 916:	df 93       	push	r29
 918:	cf 93       	push	r28
 91a:	00 d0       	rcall	.+0      	; 0x91c <MDIO_U8GetPinValue+0x6>
 91c:	00 d0       	rcall	.+0      	; 0x91e <MDIO_U8GetPinValue+0x8>
 91e:	0f 92       	push	r0
 920:	cd b7       	in	r28, 0x3d	; 61
 922:	de b7       	in	r29, 0x3e	; 62
 924:	8a 83       	std	Y+2, r24	; 0x02
 926:	6b 83       	std	Y+3, r22	; 0x03
	u8 LOC_U8RetValue;  /* Variable to store the pin value */

	/* Use the switch statement to handle different ports */
	switch (Copy_U8Port)
 928:	8a 81       	ldd	r24, Y+2	; 0x02
 92a:	28 2f       	mov	r18, r24
 92c:	30 e0       	ldi	r19, 0x00	; 0
 92e:	3d 83       	std	Y+5, r19	; 0x05
 930:	2c 83       	std	Y+4, r18	; 0x04
 932:	4c 81       	ldd	r20, Y+4	; 0x04
 934:	5d 81       	ldd	r21, Y+5	; 0x05
 936:	41 30       	cpi	r20, 0x01	; 1
 938:	51 05       	cpc	r21, r1
 93a:	41 f1       	breq	.+80     	; 0x98c <MDIO_U8GetPinValue+0x76>
 93c:	8c 81       	ldd	r24, Y+4	; 0x04
 93e:	9d 81       	ldd	r25, Y+5	; 0x05
 940:	82 30       	cpi	r24, 0x02	; 2
 942:	91 05       	cpc	r25, r1
 944:	34 f4       	brge	.+12     	; 0x952 <MDIO_U8GetPinValue+0x3c>
 946:	2c 81       	ldd	r18, Y+4	; 0x04
 948:	3d 81       	ldd	r19, Y+5	; 0x05
 94a:	21 15       	cp	r18, r1
 94c:	31 05       	cpc	r19, r1
 94e:	61 f0       	breq	.+24     	; 0x968 <MDIO_U8GetPinValue+0x52>
 950:	52 c0       	rjmp	.+164    	; 0x9f6 <MDIO_U8GetPinValue+0xe0>
 952:	4c 81       	ldd	r20, Y+4	; 0x04
 954:	5d 81       	ldd	r21, Y+5	; 0x05
 956:	42 30       	cpi	r20, 0x02	; 2
 958:	51 05       	cpc	r21, r1
 95a:	51 f1       	breq	.+84     	; 0x9b0 <MDIO_U8GetPinValue+0x9a>
 95c:	8c 81       	ldd	r24, Y+4	; 0x04
 95e:	9d 81       	ldd	r25, Y+5	; 0x05
 960:	83 30       	cpi	r24, 0x03	; 3
 962:	91 05       	cpc	r25, r1
 964:	b9 f1       	breq	.+110    	; 0x9d4 <MDIO_U8GetPinValue+0xbe>
 966:	47 c0       	rjmp	.+142    	; 0x9f6 <MDIO_U8GetPinValue+0xe0>
	{
	case 0:
		/* Get the value of the specified pin from PINA register */
		LOC_U8RetValue = GET_BIT(PINA_REG, Copy_U8Pin);
 968:	e9 e3       	ldi	r30, 0x39	; 57
 96a:	f0 e0       	ldi	r31, 0x00	; 0
 96c:	80 81       	ld	r24, Z
 96e:	28 2f       	mov	r18, r24
 970:	30 e0       	ldi	r19, 0x00	; 0
 972:	8b 81       	ldd	r24, Y+3	; 0x03
 974:	88 2f       	mov	r24, r24
 976:	90 e0       	ldi	r25, 0x00	; 0
 978:	a9 01       	movw	r20, r18
 97a:	02 c0       	rjmp	.+4      	; 0x980 <MDIO_U8GetPinValue+0x6a>
 97c:	55 95       	asr	r21
 97e:	47 95       	ror	r20
 980:	8a 95       	dec	r24
 982:	e2 f7       	brpl	.-8      	; 0x97c <MDIO_U8GetPinValue+0x66>
 984:	ca 01       	movw	r24, r20
 986:	81 70       	andi	r24, 0x01	; 1
 988:	89 83       	std	Y+1, r24	; 0x01
 98a:	35 c0       	rjmp	.+106    	; 0x9f6 <MDIO_U8GetPinValue+0xe0>
		break;
	case 1:
		/* Get the value of the specified pin from PINB register */
		LOC_U8RetValue = GET_BIT(PINB_REG, Copy_U8Pin);
 98c:	e6 e3       	ldi	r30, 0x36	; 54
 98e:	f0 e0       	ldi	r31, 0x00	; 0
 990:	80 81       	ld	r24, Z
 992:	28 2f       	mov	r18, r24
 994:	30 e0       	ldi	r19, 0x00	; 0
 996:	8b 81       	ldd	r24, Y+3	; 0x03
 998:	88 2f       	mov	r24, r24
 99a:	90 e0       	ldi	r25, 0x00	; 0
 99c:	a9 01       	movw	r20, r18
 99e:	02 c0       	rjmp	.+4      	; 0x9a4 <MDIO_U8GetPinValue+0x8e>
 9a0:	55 95       	asr	r21
 9a2:	47 95       	ror	r20
 9a4:	8a 95       	dec	r24
 9a6:	e2 f7       	brpl	.-8      	; 0x9a0 <MDIO_U8GetPinValue+0x8a>
 9a8:	ca 01       	movw	r24, r20
 9aa:	81 70       	andi	r24, 0x01	; 1
 9ac:	89 83       	std	Y+1, r24	; 0x01
 9ae:	23 c0       	rjmp	.+70     	; 0x9f6 <MDIO_U8GetPinValue+0xe0>
		break;
	case 2:
		/* Get the value of the specified pin from PINC register */
		LOC_U8RetValue = GET_BIT(PINC_REG, Copy_U8Pin);
 9b0:	e3 e3       	ldi	r30, 0x33	; 51
 9b2:	f0 e0       	ldi	r31, 0x00	; 0
 9b4:	80 81       	ld	r24, Z
 9b6:	28 2f       	mov	r18, r24
 9b8:	30 e0       	ldi	r19, 0x00	; 0
 9ba:	8b 81       	ldd	r24, Y+3	; 0x03
 9bc:	88 2f       	mov	r24, r24
 9be:	90 e0       	ldi	r25, 0x00	; 0
 9c0:	a9 01       	movw	r20, r18
 9c2:	02 c0       	rjmp	.+4      	; 0x9c8 <MDIO_U8GetPinValue+0xb2>
 9c4:	55 95       	asr	r21
 9c6:	47 95       	ror	r20
 9c8:	8a 95       	dec	r24
 9ca:	e2 f7       	brpl	.-8      	; 0x9c4 <MDIO_U8GetPinValue+0xae>
 9cc:	ca 01       	movw	r24, r20
 9ce:	81 70       	andi	r24, 0x01	; 1
 9d0:	89 83       	std	Y+1, r24	; 0x01
 9d2:	11 c0       	rjmp	.+34     	; 0x9f6 <MDIO_U8GetPinValue+0xe0>
		break;
	case 3:
		/* Get the value of the specified pin from PIND register */
		LOC_U8RetValue = GET_BIT(PIND_REG, Copy_U8Pin);
 9d4:	e0 e3       	ldi	r30, 0x30	; 48
 9d6:	f0 e0       	ldi	r31, 0x00	; 0
 9d8:	80 81       	ld	r24, Z
 9da:	28 2f       	mov	r18, r24
 9dc:	30 e0       	ldi	r19, 0x00	; 0
 9de:	8b 81       	ldd	r24, Y+3	; 0x03
 9e0:	88 2f       	mov	r24, r24
 9e2:	90 e0       	ldi	r25, 0x00	; 0
 9e4:	a9 01       	movw	r20, r18
 9e6:	02 c0       	rjmp	.+4      	; 0x9ec <MDIO_U8GetPinValue+0xd6>
 9e8:	55 95       	asr	r21
 9ea:	47 95       	ror	r20
 9ec:	8a 95       	dec	r24
 9ee:	e2 f7       	brpl	.-8      	; 0x9e8 <MDIO_U8GetPinValue+0xd2>
 9f0:	ca 01       	movw	r24, r20
 9f2:	81 70       	andi	r24, 0x01	; 1
 9f4:	89 83       	std	Y+1, r24	; 0x01
		/* Invalid port, do nothing */
		break;
	}

	/* Return the value of the pin (0 or 1) */
	return LOC_U8RetValue;
 9f6:	89 81       	ldd	r24, Y+1	; 0x01
}
 9f8:	0f 90       	pop	r0
 9fa:	0f 90       	pop	r0
 9fc:	0f 90       	pop	r0
 9fe:	0f 90       	pop	r0
 a00:	0f 90       	pop	r0
 a02:	cf 91       	pop	r28
 a04:	df 91       	pop	r29
 a06:	08 95       	ret

00000a08 <MDIO_VOIDSetPortValue>:
 *      - Copy_U8Port: The port number (0 to 3)
 *      - Copy_U8PortValue: The value to set (8-bit value)
 * Return: None
 ************************************************************************************/
void MDIO_VOIDSetPortValue(u8 Copy_U8Port, u8 Copy_U8PortValue)
{
 a08:	df 93       	push	r29
 a0a:	cf 93       	push	r28
 a0c:	00 d0       	rcall	.+0      	; 0xa0e <MDIO_VOIDSetPortValue+0x6>
 a0e:	00 d0       	rcall	.+0      	; 0xa10 <MDIO_VOIDSetPortValue+0x8>
 a10:	cd b7       	in	r28, 0x3d	; 61
 a12:	de b7       	in	r29, 0x3e	; 62
 a14:	89 83       	std	Y+1, r24	; 0x01
 a16:	6a 83       	std	Y+2, r22	; 0x02
	/* Use the switch statement to handle different ports */
	switch (Copy_U8Port)
 a18:	89 81       	ldd	r24, Y+1	; 0x01
 a1a:	28 2f       	mov	r18, r24
 a1c:	30 e0       	ldi	r19, 0x00	; 0
 a1e:	3c 83       	std	Y+4, r19	; 0x04
 a20:	2b 83       	std	Y+3, r18	; 0x03
 a22:	8b 81       	ldd	r24, Y+3	; 0x03
 a24:	9c 81       	ldd	r25, Y+4	; 0x04
 a26:	81 30       	cpi	r24, 0x01	; 1
 a28:	91 05       	cpc	r25, r1
 a2a:	d1 f0       	breq	.+52     	; 0xa60 <MDIO_VOIDSetPortValue+0x58>
 a2c:	2b 81       	ldd	r18, Y+3	; 0x03
 a2e:	3c 81       	ldd	r19, Y+4	; 0x04
 a30:	22 30       	cpi	r18, 0x02	; 2
 a32:	31 05       	cpc	r19, r1
 a34:	2c f4       	brge	.+10     	; 0xa40 <MDIO_VOIDSetPortValue+0x38>
 a36:	8b 81       	ldd	r24, Y+3	; 0x03
 a38:	9c 81       	ldd	r25, Y+4	; 0x04
 a3a:	00 97       	sbiw	r24, 0x00	; 0
 a3c:	61 f0       	breq	.+24     	; 0xa56 <MDIO_VOIDSetPortValue+0x4e>
 a3e:	1e c0       	rjmp	.+60     	; 0xa7c <MDIO_VOIDSetPortValue+0x74>
 a40:	2b 81       	ldd	r18, Y+3	; 0x03
 a42:	3c 81       	ldd	r19, Y+4	; 0x04
 a44:	22 30       	cpi	r18, 0x02	; 2
 a46:	31 05       	cpc	r19, r1
 a48:	81 f0       	breq	.+32     	; 0xa6a <MDIO_VOIDSetPortValue+0x62>
 a4a:	8b 81       	ldd	r24, Y+3	; 0x03
 a4c:	9c 81       	ldd	r25, Y+4	; 0x04
 a4e:	83 30       	cpi	r24, 0x03	; 3
 a50:	91 05       	cpc	r25, r1
 a52:	81 f0       	breq	.+32     	; 0xa74 <MDIO_VOIDSetPortValue+0x6c>
 a54:	13 c0       	rjmp	.+38     	; 0xa7c <MDIO_VOIDSetPortValue+0x74>
	{
	case 0:
		/* Assign the value to the PORTA register */
		PORTA_REG = Copy_U8PortValue;
 a56:	eb e3       	ldi	r30, 0x3B	; 59
 a58:	f0 e0       	ldi	r31, 0x00	; 0
 a5a:	8a 81       	ldd	r24, Y+2	; 0x02
 a5c:	80 83       	st	Z, r24
 a5e:	0e c0       	rjmp	.+28     	; 0xa7c <MDIO_VOIDSetPortValue+0x74>
		break;
	case 1:
		/* Assign the value to the PORTB register */
		PORTB_REG = Copy_U8PortValue;
 a60:	e8 e3       	ldi	r30, 0x38	; 56
 a62:	f0 e0       	ldi	r31, 0x00	; 0
 a64:	8a 81       	ldd	r24, Y+2	; 0x02
 a66:	80 83       	st	Z, r24
 a68:	09 c0       	rjmp	.+18     	; 0xa7c <MDIO_VOIDSetPortValue+0x74>
		break;
	case 2:
		/* Assign the value to the PORTC register */
		PORTC_REG = Copy_U8PortValue;
 a6a:	e5 e3       	ldi	r30, 0x35	; 53
 a6c:	f0 e0       	ldi	r31, 0x00	; 0
 a6e:	8a 81       	ldd	r24, Y+2	; 0x02
 a70:	80 83       	st	Z, r24
 a72:	04 c0       	rjmp	.+8      	; 0xa7c <MDIO_VOIDSetPortValue+0x74>
		break;
	case 3:
		/* Assign the value to the PORTD register */
		PORTD_REG = Copy_U8PortValue;
 a74:	e2 e3       	ldi	r30, 0x32	; 50
 a76:	f0 e0       	ldi	r31, 0x00	; 0
 a78:	8a 81       	ldd	r24, Y+2	; 0x02
 a7a:	80 83       	st	Z, r24
		break;
	default:
		/* Invalid port, do nothing */
		break;
	}
}
 a7c:	0f 90       	pop	r0
 a7e:	0f 90       	pop	r0
 a80:	0f 90       	pop	r0
 a82:	0f 90       	pop	r0
 a84:	cf 91       	pop	r28
 a86:	df 91       	pop	r29
 a88:	08 95       	ret

00000a8a <MDIO_VOIDSetPinValue>:
 *      - Copy_U8Pin: The pin number (0 to 7)
 *      - Copy_U8Value: The value to set (1 for HIGH, 0 for LOW)
 * Return: None
 ************************************************************************************/
void MDIO_VOIDSetPinValue(u8 Copy_U8Port, u8 Copy_U8Pin, u8 Copy_U8Value)
{
 a8a:	df 93       	push	r29
 a8c:	cf 93       	push	r28
 a8e:	cd b7       	in	r28, 0x3d	; 61
 a90:	de b7       	in	r29, 0x3e	; 62
 a92:	27 97       	sbiw	r28, 0x07	; 7
 a94:	0f b6       	in	r0, 0x3f	; 63
 a96:	f8 94       	cli
 a98:	de bf       	out	0x3e, r29	; 62
 a9a:	0f be       	out	0x3f, r0	; 63
 a9c:	cd bf       	out	0x3d, r28	; 61
 a9e:	89 83       	std	Y+1, r24	; 0x01
 aa0:	6a 83       	std	Y+2, r22	; 0x02
 aa2:	4b 83       	std	Y+3, r20	; 0x03
	/* Check if the desired value is HIGH (1) */
	if (1 == Copy_U8Value)
 aa4:	8b 81       	ldd	r24, Y+3	; 0x03
 aa6:	81 30       	cpi	r24, 0x01	; 1
 aa8:	09 f0       	breq	.+2      	; 0xaac <MDIO_VOIDSetPinValue+0x22>
 aaa:	6f c0       	rjmp	.+222    	; 0xb8a <MDIO_VOIDSetPinValue+0x100>
	{
		/* Use the switch statement to handle different ports */
		switch (Copy_U8Port)
 aac:	89 81       	ldd	r24, Y+1	; 0x01
 aae:	28 2f       	mov	r18, r24
 ab0:	30 e0       	ldi	r19, 0x00	; 0
 ab2:	3f 83       	std	Y+7, r19	; 0x07
 ab4:	2e 83       	std	Y+6, r18	; 0x06
 ab6:	8e 81       	ldd	r24, Y+6	; 0x06
 ab8:	9f 81       	ldd	r25, Y+7	; 0x07
 aba:	81 30       	cpi	r24, 0x01	; 1
 abc:	91 05       	cpc	r25, r1
 abe:	49 f1       	breq	.+82     	; 0xb12 <MDIO_VOIDSetPinValue+0x88>
 ac0:	2e 81       	ldd	r18, Y+6	; 0x06
 ac2:	3f 81       	ldd	r19, Y+7	; 0x07
 ac4:	22 30       	cpi	r18, 0x02	; 2
 ac6:	31 05       	cpc	r19, r1
 ac8:	2c f4       	brge	.+10     	; 0xad4 <MDIO_VOIDSetPinValue+0x4a>
 aca:	8e 81       	ldd	r24, Y+6	; 0x06
 acc:	9f 81       	ldd	r25, Y+7	; 0x07
 ace:	00 97       	sbiw	r24, 0x00	; 0
 ad0:	61 f0       	breq	.+24     	; 0xaea <MDIO_VOIDSetPinValue+0x60>
 ad2:	d2 c0       	rjmp	.+420    	; 0xc78 <MDIO_VOIDSetPinValue+0x1ee>
 ad4:	2e 81       	ldd	r18, Y+6	; 0x06
 ad6:	3f 81       	ldd	r19, Y+7	; 0x07
 ad8:	22 30       	cpi	r18, 0x02	; 2
 ada:	31 05       	cpc	r19, r1
 adc:	71 f1       	breq	.+92     	; 0xb3a <MDIO_VOIDSetPinValue+0xb0>
 ade:	8e 81       	ldd	r24, Y+6	; 0x06
 ae0:	9f 81       	ldd	r25, Y+7	; 0x07
 ae2:	83 30       	cpi	r24, 0x03	; 3
 ae4:	91 05       	cpc	r25, r1
 ae6:	e9 f1       	breq	.+122    	; 0xb62 <MDIO_VOIDSetPinValue+0xd8>
 ae8:	c7 c0       	rjmp	.+398    	; 0xc78 <MDIO_VOIDSetPinValue+0x1ee>
		{
		case 0:
			/* Set the corresponding bit in PORTA register to HIGH */
			SET_BIT(PORTA_REG, Copy_U8Pin);
 aea:	ab e3       	ldi	r26, 0x3B	; 59
 aec:	b0 e0       	ldi	r27, 0x00	; 0
 aee:	eb e3       	ldi	r30, 0x3B	; 59
 af0:	f0 e0       	ldi	r31, 0x00	; 0
 af2:	80 81       	ld	r24, Z
 af4:	48 2f       	mov	r20, r24
 af6:	8a 81       	ldd	r24, Y+2	; 0x02
 af8:	28 2f       	mov	r18, r24
 afa:	30 e0       	ldi	r19, 0x00	; 0
 afc:	81 e0       	ldi	r24, 0x01	; 1
 afe:	90 e0       	ldi	r25, 0x00	; 0
 b00:	02 2e       	mov	r0, r18
 b02:	02 c0       	rjmp	.+4      	; 0xb08 <MDIO_VOIDSetPinValue+0x7e>
 b04:	88 0f       	add	r24, r24
 b06:	99 1f       	adc	r25, r25
 b08:	0a 94       	dec	r0
 b0a:	e2 f7       	brpl	.-8      	; 0xb04 <MDIO_VOIDSetPinValue+0x7a>
 b0c:	84 2b       	or	r24, r20
 b0e:	8c 93       	st	X, r24
 b10:	b3 c0       	rjmp	.+358    	; 0xc78 <MDIO_VOIDSetPinValue+0x1ee>
			break;
		case 1:
			/* Set the corresponding bit in PORTB register to HIGH */
			SET_BIT(PORTB_REG, Copy_U8Pin);
 b12:	a8 e3       	ldi	r26, 0x38	; 56
 b14:	b0 e0       	ldi	r27, 0x00	; 0
 b16:	e8 e3       	ldi	r30, 0x38	; 56
 b18:	f0 e0       	ldi	r31, 0x00	; 0
 b1a:	80 81       	ld	r24, Z
 b1c:	48 2f       	mov	r20, r24
 b1e:	8a 81       	ldd	r24, Y+2	; 0x02
 b20:	28 2f       	mov	r18, r24
 b22:	30 e0       	ldi	r19, 0x00	; 0
 b24:	81 e0       	ldi	r24, 0x01	; 1
 b26:	90 e0       	ldi	r25, 0x00	; 0
 b28:	02 2e       	mov	r0, r18
 b2a:	02 c0       	rjmp	.+4      	; 0xb30 <MDIO_VOIDSetPinValue+0xa6>
 b2c:	88 0f       	add	r24, r24
 b2e:	99 1f       	adc	r25, r25
 b30:	0a 94       	dec	r0
 b32:	e2 f7       	brpl	.-8      	; 0xb2c <MDIO_VOIDSetPinValue+0xa2>
 b34:	84 2b       	or	r24, r20
 b36:	8c 93       	st	X, r24
 b38:	9f c0       	rjmp	.+318    	; 0xc78 <MDIO_VOIDSetPinValue+0x1ee>
			break;
		case 2:
			/* Set the corresponding bit in PORTC register to HIGH */
			SET_BIT(PORTC_REG, Copy_U8Pin);
 b3a:	a5 e3       	ldi	r26, 0x35	; 53
 b3c:	b0 e0       	ldi	r27, 0x00	; 0
 b3e:	e5 e3       	ldi	r30, 0x35	; 53
 b40:	f0 e0       	ldi	r31, 0x00	; 0
 b42:	80 81       	ld	r24, Z
 b44:	48 2f       	mov	r20, r24
 b46:	8a 81       	ldd	r24, Y+2	; 0x02
 b48:	28 2f       	mov	r18, r24
 b4a:	30 e0       	ldi	r19, 0x00	; 0
 b4c:	81 e0       	ldi	r24, 0x01	; 1
 b4e:	90 e0       	ldi	r25, 0x00	; 0
 b50:	02 2e       	mov	r0, r18
 b52:	02 c0       	rjmp	.+4      	; 0xb58 <MDIO_VOIDSetPinValue+0xce>
 b54:	88 0f       	add	r24, r24
 b56:	99 1f       	adc	r25, r25
 b58:	0a 94       	dec	r0
 b5a:	e2 f7       	brpl	.-8      	; 0xb54 <MDIO_VOIDSetPinValue+0xca>
 b5c:	84 2b       	or	r24, r20
 b5e:	8c 93       	st	X, r24
 b60:	8b c0       	rjmp	.+278    	; 0xc78 <MDIO_VOIDSetPinValue+0x1ee>
			break;
		case 3:
			/* Set the corresponding bit in PORTD register to HIGH */
			SET_BIT(PORTD_REG, Copy_U8Pin);
 b62:	a2 e3       	ldi	r26, 0x32	; 50
 b64:	b0 e0       	ldi	r27, 0x00	; 0
 b66:	e2 e3       	ldi	r30, 0x32	; 50
 b68:	f0 e0       	ldi	r31, 0x00	; 0
 b6a:	80 81       	ld	r24, Z
 b6c:	48 2f       	mov	r20, r24
 b6e:	8a 81       	ldd	r24, Y+2	; 0x02
 b70:	28 2f       	mov	r18, r24
 b72:	30 e0       	ldi	r19, 0x00	; 0
 b74:	81 e0       	ldi	r24, 0x01	; 1
 b76:	90 e0       	ldi	r25, 0x00	; 0
 b78:	02 2e       	mov	r0, r18
 b7a:	02 c0       	rjmp	.+4      	; 0xb80 <MDIO_VOIDSetPinValue+0xf6>
 b7c:	88 0f       	add	r24, r24
 b7e:	99 1f       	adc	r25, r25
 b80:	0a 94       	dec	r0
 b82:	e2 f7       	brpl	.-8      	; 0xb7c <MDIO_VOIDSetPinValue+0xf2>
 b84:	84 2b       	or	r24, r20
 b86:	8c 93       	st	X, r24
 b88:	77 c0       	rjmp	.+238    	; 0xc78 <MDIO_VOIDSetPinValue+0x1ee>
			/* Invalid port, do nothing */
			break;
		}
	}
	/* Check if the desired value is LOW (0) */
	else if (0 == Copy_U8Value)
 b8a:	8b 81       	ldd	r24, Y+3	; 0x03
 b8c:	88 23       	and	r24, r24
 b8e:	09 f0       	breq	.+2      	; 0xb92 <MDIO_VOIDSetPinValue+0x108>
 b90:	73 c0       	rjmp	.+230    	; 0xc78 <MDIO_VOIDSetPinValue+0x1ee>
	{
		/* Use the switch statement to handle different ports */
		switch (Copy_U8Port)
 b92:	89 81       	ldd	r24, Y+1	; 0x01
 b94:	28 2f       	mov	r18, r24
 b96:	30 e0       	ldi	r19, 0x00	; 0
 b98:	3d 83       	std	Y+5, r19	; 0x05
 b9a:	2c 83       	std	Y+4, r18	; 0x04
 b9c:	8c 81       	ldd	r24, Y+4	; 0x04
 b9e:	9d 81       	ldd	r25, Y+5	; 0x05
 ba0:	81 30       	cpi	r24, 0x01	; 1
 ba2:	91 05       	cpc	r25, r1
 ba4:	59 f1       	breq	.+86     	; 0xbfc <MDIO_VOIDSetPinValue+0x172>
 ba6:	2c 81       	ldd	r18, Y+4	; 0x04
 ba8:	3d 81       	ldd	r19, Y+5	; 0x05
 baa:	22 30       	cpi	r18, 0x02	; 2
 bac:	31 05       	cpc	r19, r1
 bae:	2c f4       	brge	.+10     	; 0xbba <MDIO_VOIDSetPinValue+0x130>
 bb0:	8c 81       	ldd	r24, Y+4	; 0x04
 bb2:	9d 81       	ldd	r25, Y+5	; 0x05
 bb4:	00 97       	sbiw	r24, 0x00	; 0
 bb6:	69 f0       	breq	.+26     	; 0xbd2 <MDIO_VOIDSetPinValue+0x148>
 bb8:	5f c0       	rjmp	.+190    	; 0xc78 <MDIO_VOIDSetPinValue+0x1ee>
 bba:	2c 81       	ldd	r18, Y+4	; 0x04
 bbc:	3d 81       	ldd	r19, Y+5	; 0x05
 bbe:	22 30       	cpi	r18, 0x02	; 2
 bc0:	31 05       	cpc	r19, r1
 bc2:	89 f1       	breq	.+98     	; 0xc26 <MDIO_VOIDSetPinValue+0x19c>
 bc4:	8c 81       	ldd	r24, Y+4	; 0x04
 bc6:	9d 81       	ldd	r25, Y+5	; 0x05
 bc8:	83 30       	cpi	r24, 0x03	; 3
 bca:	91 05       	cpc	r25, r1
 bcc:	09 f4       	brne	.+2      	; 0xbd0 <MDIO_VOIDSetPinValue+0x146>
 bce:	40 c0       	rjmp	.+128    	; 0xc50 <MDIO_VOIDSetPinValue+0x1c6>
 bd0:	53 c0       	rjmp	.+166    	; 0xc78 <MDIO_VOIDSetPinValue+0x1ee>
		{
		case 0:
			/* Clear the corresponding bit in PORTA register to LOW */
			CLR_BIT(PORTA_REG, Copy_U8Pin);
 bd2:	ab e3       	ldi	r26, 0x3B	; 59
 bd4:	b0 e0       	ldi	r27, 0x00	; 0
 bd6:	eb e3       	ldi	r30, 0x3B	; 59
 bd8:	f0 e0       	ldi	r31, 0x00	; 0
 bda:	80 81       	ld	r24, Z
 bdc:	48 2f       	mov	r20, r24
 bde:	8a 81       	ldd	r24, Y+2	; 0x02
 be0:	28 2f       	mov	r18, r24
 be2:	30 e0       	ldi	r19, 0x00	; 0
 be4:	81 e0       	ldi	r24, 0x01	; 1
 be6:	90 e0       	ldi	r25, 0x00	; 0
 be8:	02 2e       	mov	r0, r18
 bea:	02 c0       	rjmp	.+4      	; 0xbf0 <MDIO_VOIDSetPinValue+0x166>
 bec:	88 0f       	add	r24, r24
 bee:	99 1f       	adc	r25, r25
 bf0:	0a 94       	dec	r0
 bf2:	e2 f7       	brpl	.-8      	; 0xbec <MDIO_VOIDSetPinValue+0x162>
 bf4:	80 95       	com	r24
 bf6:	84 23       	and	r24, r20
 bf8:	8c 93       	st	X, r24
 bfa:	3e c0       	rjmp	.+124    	; 0xc78 <MDIO_VOIDSetPinValue+0x1ee>
			break;
		case 1:
			/* Clear the corresponding bit in PORTB register to LOW */
			CLR_BIT(PORTB_REG, Copy_U8Pin);
 bfc:	a8 e3       	ldi	r26, 0x38	; 56
 bfe:	b0 e0       	ldi	r27, 0x00	; 0
 c00:	e8 e3       	ldi	r30, 0x38	; 56
 c02:	f0 e0       	ldi	r31, 0x00	; 0
 c04:	80 81       	ld	r24, Z
 c06:	48 2f       	mov	r20, r24
 c08:	8a 81       	ldd	r24, Y+2	; 0x02
 c0a:	28 2f       	mov	r18, r24
 c0c:	30 e0       	ldi	r19, 0x00	; 0
 c0e:	81 e0       	ldi	r24, 0x01	; 1
 c10:	90 e0       	ldi	r25, 0x00	; 0
 c12:	02 2e       	mov	r0, r18
 c14:	02 c0       	rjmp	.+4      	; 0xc1a <MDIO_VOIDSetPinValue+0x190>
 c16:	88 0f       	add	r24, r24
 c18:	99 1f       	adc	r25, r25
 c1a:	0a 94       	dec	r0
 c1c:	e2 f7       	brpl	.-8      	; 0xc16 <MDIO_VOIDSetPinValue+0x18c>
 c1e:	80 95       	com	r24
 c20:	84 23       	and	r24, r20
 c22:	8c 93       	st	X, r24
 c24:	29 c0       	rjmp	.+82     	; 0xc78 <MDIO_VOIDSetPinValue+0x1ee>
			break;
		case 2:
			/* Clear the corresponding bit in PORTC register to LOW */
			CLR_BIT(PORTC_REG, Copy_U8Pin);
 c26:	a5 e3       	ldi	r26, 0x35	; 53
 c28:	b0 e0       	ldi	r27, 0x00	; 0
 c2a:	e5 e3       	ldi	r30, 0x35	; 53
 c2c:	f0 e0       	ldi	r31, 0x00	; 0
 c2e:	80 81       	ld	r24, Z
 c30:	48 2f       	mov	r20, r24
 c32:	8a 81       	ldd	r24, Y+2	; 0x02
 c34:	28 2f       	mov	r18, r24
 c36:	30 e0       	ldi	r19, 0x00	; 0
 c38:	81 e0       	ldi	r24, 0x01	; 1
 c3a:	90 e0       	ldi	r25, 0x00	; 0
 c3c:	02 2e       	mov	r0, r18
 c3e:	02 c0       	rjmp	.+4      	; 0xc44 <MDIO_VOIDSetPinValue+0x1ba>
 c40:	88 0f       	add	r24, r24
 c42:	99 1f       	adc	r25, r25
 c44:	0a 94       	dec	r0
 c46:	e2 f7       	brpl	.-8      	; 0xc40 <MDIO_VOIDSetPinValue+0x1b6>
 c48:	80 95       	com	r24
 c4a:	84 23       	and	r24, r20
 c4c:	8c 93       	st	X, r24
 c4e:	14 c0       	rjmp	.+40     	; 0xc78 <MDIO_VOIDSetPinValue+0x1ee>
			break;
		case 3:
			/* Clear the corresponding bit in PORTD register to LOW */
			CLR_BIT(PORTD_REG, Copy_U8Pin);
 c50:	a2 e3       	ldi	r26, 0x32	; 50
 c52:	b0 e0       	ldi	r27, 0x00	; 0
 c54:	e2 e3       	ldi	r30, 0x32	; 50
 c56:	f0 e0       	ldi	r31, 0x00	; 0
 c58:	80 81       	ld	r24, Z
 c5a:	48 2f       	mov	r20, r24
 c5c:	8a 81       	ldd	r24, Y+2	; 0x02
 c5e:	28 2f       	mov	r18, r24
 c60:	30 e0       	ldi	r19, 0x00	; 0
 c62:	81 e0       	ldi	r24, 0x01	; 1
 c64:	90 e0       	ldi	r25, 0x00	; 0
 c66:	02 2e       	mov	r0, r18
 c68:	02 c0       	rjmp	.+4      	; 0xc6e <MDIO_VOIDSetPinValue+0x1e4>
 c6a:	88 0f       	add	r24, r24
 c6c:	99 1f       	adc	r25, r25
 c6e:	0a 94       	dec	r0
 c70:	e2 f7       	brpl	.-8      	; 0xc6a <MDIO_VOIDSetPinValue+0x1e0>
 c72:	80 95       	com	r24
 c74:	84 23       	and	r24, r20
 c76:	8c 93       	st	X, r24
	}
	else
	{
		/* Invalid value, do nothing */
	}
}
 c78:	27 96       	adiw	r28, 0x07	; 7
 c7a:	0f b6       	in	r0, 0x3f	; 63
 c7c:	f8 94       	cli
 c7e:	de bf       	out	0x3e, r29	; 62
 c80:	0f be       	out	0x3f, r0	; 63
 c82:	cd bf       	out	0x3d, r28	; 61
 c84:	cf 91       	pop	r28
 c86:	df 91       	pop	r29
 c88:	08 95       	ret

00000c8a <MDIO_VOIDTogglePinValue>:
 *      - Copy_U8Port: The port number (0 to 3)
 *      - Copy_U8Pin: The pin number (0 to 7)
 * Return: None
 ************************************************************************************/
void MDIO_VOIDTogglePinValue(u8 Copy_U8Port, u8 Copy_U8Pin)
{
 c8a:	df 93       	push	r29
 c8c:	cf 93       	push	r28
 c8e:	00 d0       	rcall	.+0      	; 0xc90 <MDIO_VOIDTogglePinValue+0x6>
 c90:	00 d0       	rcall	.+0      	; 0xc92 <MDIO_VOIDTogglePinValue+0x8>
 c92:	cd b7       	in	r28, 0x3d	; 61
 c94:	de b7       	in	r29, 0x3e	; 62
 c96:	89 83       	std	Y+1, r24	; 0x01
 c98:	6a 83       	std	Y+2, r22	; 0x02
	/* Use the switch statement to handle different ports */
	switch (Copy_U8Port)
 c9a:	89 81       	ldd	r24, Y+1	; 0x01
 c9c:	28 2f       	mov	r18, r24
 c9e:	30 e0       	ldi	r19, 0x00	; 0
 ca0:	3c 83       	std	Y+4, r19	; 0x04
 ca2:	2b 83       	std	Y+3, r18	; 0x03
 ca4:	8b 81       	ldd	r24, Y+3	; 0x03
 ca6:	9c 81       	ldd	r25, Y+4	; 0x04
 ca8:	81 30       	cpi	r24, 0x01	; 1
 caa:	91 05       	cpc	r25, r1
 cac:	49 f1       	breq	.+82     	; 0xd00 <MDIO_VOIDTogglePinValue+0x76>
 cae:	2b 81       	ldd	r18, Y+3	; 0x03
 cb0:	3c 81       	ldd	r19, Y+4	; 0x04
 cb2:	22 30       	cpi	r18, 0x02	; 2
 cb4:	31 05       	cpc	r19, r1
 cb6:	2c f4       	brge	.+10     	; 0xcc2 <MDIO_VOIDTogglePinValue+0x38>
 cb8:	8b 81       	ldd	r24, Y+3	; 0x03
 cba:	9c 81       	ldd	r25, Y+4	; 0x04
 cbc:	00 97       	sbiw	r24, 0x00	; 0
 cbe:	61 f0       	breq	.+24     	; 0xcd8 <MDIO_VOIDTogglePinValue+0x4e>
 cc0:	5a c0       	rjmp	.+180    	; 0xd76 <MDIO_VOIDTogglePinValue+0xec>
 cc2:	2b 81       	ldd	r18, Y+3	; 0x03
 cc4:	3c 81       	ldd	r19, Y+4	; 0x04
 cc6:	22 30       	cpi	r18, 0x02	; 2
 cc8:	31 05       	cpc	r19, r1
 cca:	71 f1       	breq	.+92     	; 0xd28 <MDIO_VOIDTogglePinValue+0x9e>
 ccc:	8b 81       	ldd	r24, Y+3	; 0x03
 cce:	9c 81       	ldd	r25, Y+4	; 0x04
 cd0:	83 30       	cpi	r24, 0x03	; 3
 cd2:	91 05       	cpc	r25, r1
 cd4:	e9 f1       	breq	.+122    	; 0xd50 <MDIO_VOIDTogglePinValue+0xc6>
 cd6:	4f c0       	rjmp	.+158    	; 0xd76 <MDIO_VOIDTogglePinValue+0xec>
	{
	case 0:
		/* Toggle the value of the pin in PORTA register */
		TOGGLE_BIT(PORTA_REG, Copy_U8Pin);
 cd8:	ab e3       	ldi	r26, 0x3B	; 59
 cda:	b0 e0       	ldi	r27, 0x00	; 0
 cdc:	eb e3       	ldi	r30, 0x3B	; 59
 cde:	f0 e0       	ldi	r31, 0x00	; 0
 ce0:	80 81       	ld	r24, Z
 ce2:	48 2f       	mov	r20, r24
 ce4:	8a 81       	ldd	r24, Y+2	; 0x02
 ce6:	28 2f       	mov	r18, r24
 ce8:	30 e0       	ldi	r19, 0x00	; 0
 cea:	81 e0       	ldi	r24, 0x01	; 1
 cec:	90 e0       	ldi	r25, 0x00	; 0
 cee:	02 2e       	mov	r0, r18
 cf0:	02 c0       	rjmp	.+4      	; 0xcf6 <MDIO_VOIDTogglePinValue+0x6c>
 cf2:	88 0f       	add	r24, r24
 cf4:	99 1f       	adc	r25, r25
 cf6:	0a 94       	dec	r0
 cf8:	e2 f7       	brpl	.-8      	; 0xcf2 <MDIO_VOIDTogglePinValue+0x68>
 cfa:	84 27       	eor	r24, r20
 cfc:	8c 93       	st	X, r24
 cfe:	3b c0       	rjmp	.+118    	; 0xd76 <MDIO_VOIDTogglePinValue+0xec>
		break;
	case 1:
		/* Toggle the value of the pin in PORTB register */
		TOGGLE_BIT(PORTB_REG, Copy_U8Pin);
 d00:	a8 e3       	ldi	r26, 0x38	; 56
 d02:	b0 e0       	ldi	r27, 0x00	; 0
 d04:	e8 e3       	ldi	r30, 0x38	; 56
 d06:	f0 e0       	ldi	r31, 0x00	; 0
 d08:	80 81       	ld	r24, Z
 d0a:	48 2f       	mov	r20, r24
 d0c:	8a 81       	ldd	r24, Y+2	; 0x02
 d0e:	28 2f       	mov	r18, r24
 d10:	30 e0       	ldi	r19, 0x00	; 0
 d12:	81 e0       	ldi	r24, 0x01	; 1
 d14:	90 e0       	ldi	r25, 0x00	; 0
 d16:	02 2e       	mov	r0, r18
 d18:	02 c0       	rjmp	.+4      	; 0xd1e <MDIO_VOIDTogglePinValue+0x94>
 d1a:	88 0f       	add	r24, r24
 d1c:	99 1f       	adc	r25, r25
 d1e:	0a 94       	dec	r0
 d20:	e2 f7       	brpl	.-8      	; 0xd1a <MDIO_VOIDTogglePinValue+0x90>
 d22:	84 27       	eor	r24, r20
 d24:	8c 93       	st	X, r24
 d26:	27 c0       	rjmp	.+78     	; 0xd76 <MDIO_VOIDTogglePinValue+0xec>
		break;
	case 2:
		/* Toggle the value of the pin in PORTC register */
		TOGGLE_BIT(PORTC_REG, Copy_U8Pin);
 d28:	a5 e3       	ldi	r26, 0x35	; 53
 d2a:	b0 e0       	ldi	r27, 0x00	; 0
 d2c:	e5 e3       	ldi	r30, 0x35	; 53
 d2e:	f0 e0       	ldi	r31, 0x00	; 0
 d30:	80 81       	ld	r24, Z
 d32:	48 2f       	mov	r20, r24
 d34:	8a 81       	ldd	r24, Y+2	; 0x02
 d36:	28 2f       	mov	r18, r24
 d38:	30 e0       	ldi	r19, 0x00	; 0
 d3a:	81 e0       	ldi	r24, 0x01	; 1
 d3c:	90 e0       	ldi	r25, 0x00	; 0
 d3e:	02 2e       	mov	r0, r18
 d40:	02 c0       	rjmp	.+4      	; 0xd46 <MDIO_VOIDTogglePinValue+0xbc>
 d42:	88 0f       	add	r24, r24
 d44:	99 1f       	adc	r25, r25
 d46:	0a 94       	dec	r0
 d48:	e2 f7       	brpl	.-8      	; 0xd42 <MDIO_VOIDTogglePinValue+0xb8>
 d4a:	84 27       	eor	r24, r20
 d4c:	8c 93       	st	X, r24
 d4e:	13 c0       	rjmp	.+38     	; 0xd76 <MDIO_VOIDTogglePinValue+0xec>
		break;
	case 3:
		/* Toggle the value of the pin in PORTD register */
		TOGGLE_BIT(PORTD_REG, Copy_U8Pin);
 d50:	a2 e3       	ldi	r26, 0x32	; 50
 d52:	b0 e0       	ldi	r27, 0x00	; 0
 d54:	e2 e3       	ldi	r30, 0x32	; 50
 d56:	f0 e0       	ldi	r31, 0x00	; 0
 d58:	80 81       	ld	r24, Z
 d5a:	48 2f       	mov	r20, r24
 d5c:	8a 81       	ldd	r24, Y+2	; 0x02
 d5e:	28 2f       	mov	r18, r24
 d60:	30 e0       	ldi	r19, 0x00	; 0
 d62:	81 e0       	ldi	r24, 0x01	; 1
 d64:	90 e0       	ldi	r25, 0x00	; 0
 d66:	02 2e       	mov	r0, r18
 d68:	02 c0       	rjmp	.+4      	; 0xd6e <MDIO_VOIDTogglePinValue+0xe4>
 d6a:	88 0f       	add	r24, r24
 d6c:	99 1f       	adc	r25, r25
 d6e:	0a 94       	dec	r0
 d70:	e2 f7       	brpl	.-8      	; 0xd6a <MDIO_VOIDTogglePinValue+0xe0>
 d72:	84 27       	eor	r24, r20
 d74:	8c 93       	st	X, r24
		break;
	default:
		/* Invalid port, do nothing */
		break;
	}
}
 d76:	0f 90       	pop	r0
 d78:	0f 90       	pop	r0
 d7a:	0f 90       	pop	r0
 d7c:	0f 90       	pop	r0
 d7e:	cf 91       	pop	r28
 d80:	df 91       	pop	r29
 d82:	08 95       	ret

00000d84 <MDIO_VOIDSetPortDirection>:
 *      - Copy_U8Port: The port number (0 to 3)
 *      - Copy_U8Direction: The direction to set (8-bit value, each bit represents a pin)
 * Return: None
 ************************************************************************************/
void MDIO_VOIDSetPortDirection(u8 Copy_U8Port, u8 Copy_U8Direction)
{
 d84:	df 93       	push	r29
 d86:	cf 93       	push	r28
 d88:	00 d0       	rcall	.+0      	; 0xd8a <MDIO_VOIDSetPortDirection+0x6>
 d8a:	00 d0       	rcall	.+0      	; 0xd8c <MDIO_VOIDSetPortDirection+0x8>
 d8c:	cd b7       	in	r28, 0x3d	; 61
 d8e:	de b7       	in	r29, 0x3e	; 62
 d90:	89 83       	std	Y+1, r24	; 0x01
 d92:	6a 83       	std	Y+2, r22	; 0x02
	/* Use the switch statement to handle different ports */
	switch (Copy_U8Port)
 d94:	89 81       	ldd	r24, Y+1	; 0x01
 d96:	28 2f       	mov	r18, r24
 d98:	30 e0       	ldi	r19, 0x00	; 0
 d9a:	3c 83       	std	Y+4, r19	; 0x04
 d9c:	2b 83       	std	Y+3, r18	; 0x03
 d9e:	8b 81       	ldd	r24, Y+3	; 0x03
 da0:	9c 81       	ldd	r25, Y+4	; 0x04
 da2:	81 30       	cpi	r24, 0x01	; 1
 da4:	91 05       	cpc	r25, r1
 da6:	d1 f0       	breq	.+52     	; 0xddc <MDIO_VOIDSetPortDirection+0x58>
 da8:	2b 81       	ldd	r18, Y+3	; 0x03
 daa:	3c 81       	ldd	r19, Y+4	; 0x04
 dac:	22 30       	cpi	r18, 0x02	; 2
 dae:	31 05       	cpc	r19, r1
 db0:	2c f4       	brge	.+10     	; 0xdbc <MDIO_VOIDSetPortDirection+0x38>
 db2:	8b 81       	ldd	r24, Y+3	; 0x03
 db4:	9c 81       	ldd	r25, Y+4	; 0x04
 db6:	00 97       	sbiw	r24, 0x00	; 0
 db8:	61 f0       	breq	.+24     	; 0xdd2 <MDIO_VOIDSetPortDirection+0x4e>
 dba:	1e c0       	rjmp	.+60     	; 0xdf8 <MDIO_VOIDSetPortDirection+0x74>
 dbc:	2b 81       	ldd	r18, Y+3	; 0x03
 dbe:	3c 81       	ldd	r19, Y+4	; 0x04
 dc0:	22 30       	cpi	r18, 0x02	; 2
 dc2:	31 05       	cpc	r19, r1
 dc4:	81 f0       	breq	.+32     	; 0xde6 <MDIO_VOIDSetPortDirection+0x62>
 dc6:	8b 81       	ldd	r24, Y+3	; 0x03
 dc8:	9c 81       	ldd	r25, Y+4	; 0x04
 dca:	83 30       	cpi	r24, 0x03	; 3
 dcc:	91 05       	cpc	r25, r1
 dce:	81 f0       	breq	.+32     	; 0xdf0 <MDIO_VOIDSetPortDirection+0x6c>
 dd0:	13 c0       	rjmp	.+38     	; 0xdf8 <MDIO_VOIDSetPortDirection+0x74>
	{
	case 0:
		/* Set the direction for all pins in PORTA register */
		DDRA_REG = Copy_U8Direction;
 dd2:	ea e3       	ldi	r30, 0x3A	; 58
 dd4:	f0 e0       	ldi	r31, 0x00	; 0
 dd6:	8a 81       	ldd	r24, Y+2	; 0x02
 dd8:	80 83       	st	Z, r24
 dda:	0e c0       	rjmp	.+28     	; 0xdf8 <MDIO_VOIDSetPortDirection+0x74>
		break;
	case 1:
		/* Set the direction for all pins in PORTB register */
		DDRB_REG = Copy_U8Direction;
 ddc:	e7 e3       	ldi	r30, 0x37	; 55
 dde:	f0 e0       	ldi	r31, 0x00	; 0
 de0:	8a 81       	ldd	r24, Y+2	; 0x02
 de2:	80 83       	st	Z, r24
 de4:	09 c0       	rjmp	.+18     	; 0xdf8 <MDIO_VOIDSetPortDirection+0x74>
		break;
	case 2:
		/* Set the direction for all pins in PORTC register */
		DDRC_REG = Copy_U8Direction;
 de6:	e4 e3       	ldi	r30, 0x34	; 52
 de8:	f0 e0       	ldi	r31, 0x00	; 0
 dea:	8a 81       	ldd	r24, Y+2	; 0x02
 dec:	80 83       	st	Z, r24
 dee:	04 c0       	rjmp	.+8      	; 0xdf8 <MDIO_VOIDSetPortDirection+0x74>
		break;
	case 3:
		/* Set the direction for all pins in PORTD register */
		DDRD_REG = Copy_U8Direction;
 df0:	e1 e3       	ldi	r30, 0x31	; 49
 df2:	f0 e0       	ldi	r31, 0x00	; 0
 df4:	8a 81       	ldd	r24, Y+2	; 0x02
 df6:	80 83       	st	Z, r24
		break;
	default:
		/* Invalid port, do nothing */
		break;
	}
}
 df8:	0f 90       	pop	r0
 dfa:	0f 90       	pop	r0
 dfc:	0f 90       	pop	r0
 dfe:	0f 90       	pop	r0
 e00:	cf 91       	pop	r28
 e02:	df 91       	pop	r29
 e04:	08 95       	ret

00000e06 <MDIO_U8GetPortValue>:
 * Parameters:
 *      - Copy_U8Port: The port number (0 to 3)
 * Return: The value of the port (8-bit value where each bit represents a pin)
 ************************************************************************************/
u8 MDIO_U8GetPortValue(u8 Copy_U8Port)
{
 e06:	df 93       	push	r29
 e08:	cf 93       	push	r28
 e0a:	00 d0       	rcall	.+0      	; 0xe0c <MDIO_U8GetPortValue+0x6>
 e0c:	00 d0       	rcall	.+0      	; 0xe0e <MDIO_U8GetPortValue+0x8>
 e0e:	cd b7       	in	r28, 0x3d	; 61
 e10:	de b7       	in	r29, 0x3e	; 62
 e12:	8a 83       	std	Y+2, r24	; 0x02
	u8 LOC_U8RetValue;  /* Variable to store the port value */

	/* Use the switch statement to handle different ports */
	switch (Copy_U8Port)
 e14:	8a 81       	ldd	r24, Y+2	; 0x02
 e16:	28 2f       	mov	r18, r24
 e18:	30 e0       	ldi	r19, 0x00	; 0
 e1a:	3c 83       	std	Y+4, r19	; 0x04
 e1c:	2b 83       	std	Y+3, r18	; 0x03
 e1e:	8b 81       	ldd	r24, Y+3	; 0x03
 e20:	9c 81       	ldd	r25, Y+4	; 0x04
 e22:	81 30       	cpi	r24, 0x01	; 1
 e24:	91 05       	cpc	r25, r1
 e26:	d1 f0       	breq	.+52     	; 0xe5c <MDIO_U8GetPortValue+0x56>
 e28:	2b 81       	ldd	r18, Y+3	; 0x03
 e2a:	3c 81       	ldd	r19, Y+4	; 0x04
 e2c:	22 30       	cpi	r18, 0x02	; 2
 e2e:	31 05       	cpc	r19, r1
 e30:	2c f4       	brge	.+10     	; 0xe3c <MDIO_U8GetPortValue+0x36>
 e32:	8b 81       	ldd	r24, Y+3	; 0x03
 e34:	9c 81       	ldd	r25, Y+4	; 0x04
 e36:	00 97       	sbiw	r24, 0x00	; 0
 e38:	61 f0       	breq	.+24     	; 0xe52 <MDIO_U8GetPortValue+0x4c>
 e3a:	1e c0       	rjmp	.+60     	; 0xe78 <MDIO_U8GetPortValue+0x72>
 e3c:	2b 81       	ldd	r18, Y+3	; 0x03
 e3e:	3c 81       	ldd	r19, Y+4	; 0x04
 e40:	22 30       	cpi	r18, 0x02	; 2
 e42:	31 05       	cpc	r19, r1
 e44:	81 f0       	breq	.+32     	; 0xe66 <MDIO_U8GetPortValue+0x60>
 e46:	8b 81       	ldd	r24, Y+3	; 0x03
 e48:	9c 81       	ldd	r25, Y+4	; 0x04
 e4a:	83 30       	cpi	r24, 0x03	; 3
 e4c:	91 05       	cpc	r25, r1
 e4e:	81 f0       	breq	.+32     	; 0xe70 <MDIO_U8GetPortValue+0x6a>
 e50:	13 c0       	rjmp	.+38     	; 0xe78 <MDIO_U8GetPortValue+0x72>
	{
	case 0:
		/* Get the value of all pins from PINA register */
		LOC_U8RetValue = PINA_REG;
 e52:	e9 e3       	ldi	r30, 0x39	; 57
 e54:	f0 e0       	ldi	r31, 0x00	; 0
 e56:	80 81       	ld	r24, Z
 e58:	89 83       	std	Y+1, r24	; 0x01
 e5a:	0e c0       	rjmp	.+28     	; 0xe78 <MDIO_U8GetPortValue+0x72>
		break;
	case 1:
		/* Get the value of all pins from PINB register */
		LOC_U8RetValue = PINB_REG;
 e5c:	e6 e3       	ldi	r30, 0x36	; 54
 e5e:	f0 e0       	ldi	r31, 0x00	; 0
 e60:	80 81       	ld	r24, Z
 e62:	89 83       	std	Y+1, r24	; 0x01
 e64:	09 c0       	rjmp	.+18     	; 0xe78 <MDIO_U8GetPortValue+0x72>
		break;
	case 2:
		/* Get the value of all pins from PINC register */
		LOC_U8RetValue = PINC_REG;
 e66:	e3 e3       	ldi	r30, 0x33	; 51
 e68:	f0 e0       	ldi	r31, 0x00	; 0
 e6a:	80 81       	ld	r24, Z
 e6c:	89 83       	std	Y+1, r24	; 0x01
 e6e:	04 c0       	rjmp	.+8      	; 0xe78 <MDIO_U8GetPortValue+0x72>
		break;
	case 3:
		/* Get the value of all pins from PIND register */
		LOC_U8RetValue = PIND_REG;
 e70:	e0 e3       	ldi	r30, 0x30	; 48
 e72:	f0 e0       	ldi	r31, 0x00	; 0
 e74:	80 81       	ld	r24, Z
 e76:	89 83       	std	Y+1, r24	; 0x01
		/* Invalid port, do nothing */
		break;
	}

	/* Return the value of the port (8-bit value) */
	return LOC_U8RetValue;
 e78:	89 81       	ldd	r24, Y+1	; 0x01
}
 e7a:	0f 90       	pop	r0
 e7c:	0f 90       	pop	r0
 e7e:	0f 90       	pop	r0
 e80:	0f 90       	pop	r0
 e82:	cf 91       	pop	r28
 e84:	df 91       	pop	r29
 e86:	08 95       	ret

00000e88 <main>:
#include "LIB/STD_TYPES.h"
#include "OS/OS_Interface.h"
#include "MCAL/DIO/MDIO_Interface.h"

int main (void)
{
 e88:	df 93       	push	r29
 e8a:	cf 93       	push	r28
 e8c:	cd b7       	in	r28, 0x3d	; 61
 e8e:	de b7       	in	r29, 0x3e	; 62
	/* Initialize animation pins on PORTC */
	MDIO_VOIDSetPortDirection(2, 0xFF);   /* Set all pins of PORTC as output */
 e90:	82 e0       	ldi	r24, 0x02	; 2
 e92:	6f ef       	ldi	r22, 0xFF	; 255
 e94:	0e 94 c2 06 	call	0xd84	; 0xd84 <MDIO_VOIDSetPortDirection>

	/* Initialize 1st 7-segment to start from zero on PORTA */
	MDIO_VOIDSetPortDirection(0, 0xFF);   /* Set all pins of PORTA as output */
 e98:	80 e0       	ldi	r24, 0x00	; 0
 e9a:	6f ef       	ldi	r22, 0xFF	; 255
 e9c:	0e 94 c2 06 	call	0xd84	; 0xd84 <MDIO_VOIDSetPortDirection>
	MDIO_VOIDSetPortValue(0, 0x3F);       /* Set PORTA to display 0 on the 7-segment */
 ea0:	80 e0       	ldi	r24, 0x00	; 0
 ea2:	6f e3       	ldi	r22, 0x3F	; 63
 ea4:	0e 94 04 05 	call	0xa08	; 0xa08 <MDIO_VOIDSetPortValue>

	/* Initialize 1st 7-segment to start from nine on PORTB */
	MDIO_VOIDSetPortDirection(1, 0xFF);   /* Set all pins of PORTB as output */
 ea8:	81 e0       	ldi	r24, 0x01	; 1
 eaa:	6f ef       	ldi	r22, 0xFF	; 255
 eac:	0e 94 c2 06 	call	0xd84	; 0xd84 <MDIO_VOIDSetPortDirection>
	MDIO_VOIDSetPortValue(1, 0x6F);       /* Set PORTB to display 9 on the 7-segment */
 eb0:	81 e0       	ldi	r24, 0x01	; 1
 eb2:	6f e6       	ldi	r22, 0x6F	; 111
 eb4:	0e 94 04 05 	call	0xa08	; 0xa08 <MDIO_VOIDSetPortValue>

	/* Initialize Door lock pins on PORTD */
	MDIO_VOIDSetPinDirection(3, 0, 1);    /* Set pin 0 of PORTD as output */
 eb8:	83 e0       	ldi	r24, 0x03	; 3
 eba:	60 e0       	ldi	r22, 0x00	; 0
 ebc:	41 e0       	ldi	r20, 0x01	; 1
 ebe:	0e 94 8b 03 	call	0x716	; 0x716 <MDIO_VOIDSetPinDirection>
	MDIO_VOIDSetPinDirection(3, 7, 1);    /* Set pin 7 of PORTD as output */
 ec2:	83 e0       	ldi	r24, 0x03	; 3
 ec4:	67 e0       	ldi	r22, 0x07	; 7
 ec6:	41 e0       	ldi	r20, 0x01	; 1
 ec8:	0e 94 8b 03 	call	0x716	; 0x716 <MDIO_VOIDSetPinDirection>

	/* Use the scheduler in the interrupt */
	MTMR0_CTC_CallbackFunction(&OS_VOIDSchedular);  /* Set the scheduler function to be called on interrupt */
 ecc:	85 e8       	ldi	r24, 0x85	; 133
 ece:	90 e0       	ldi	r25, 0x00	; 0
 ed0:	0e 94 37 02 	call	0x46e	; 0x46e <MTMR0_CTC_CallbackFunction>

	/* Creating tasks and assigning their priority and periodicity */
	OS_VOIDCreateTask(&OS_VOIDSegUp, 0, 1000);        /* Task 0: 7-segment up count every 1000ms */
 ed4:	86 e2       	ldi	r24, 0x26	; 38
 ed6:	91 e0       	ldi	r25, 0x01	; 1
 ed8:	60 e0       	ldi	r22, 0x00	; 0
 eda:	48 ee       	ldi	r20, 0xE8	; 232
 edc:	53 e0       	ldi	r21, 0x03	; 3
 ede:	0e 94 54 00 	call	0xa8	; 0xa8 <OS_VOIDCreateTask>
	OS_VOIDCreateTask(&OS_VOIDSegDown, 1, 2000);      /* Task 1: 7-segment down count every 2000ms */
 ee2:	87 e5       	ldi	r24, 0x57	; 87
 ee4:	91 e0       	ldi	r25, 0x01	; 1
 ee6:	61 e0       	ldi	r22, 0x01	; 1
 ee8:	40 ed       	ldi	r20, 0xD0	; 208
 eea:	57 e0       	ldi	r21, 0x07	; 7
 eec:	0e 94 54 00 	call	0xa8	; 0xa8 <OS_VOIDCreateTask>
	OS_VOIDCreateTask(&OS_VOIDAnimation1_1, 2, 3000); /* Task 2: Animation 1 - Stage 1 every 3000ms */
 ef0:	8e ec       	ldi	r24, 0xCE	; 206
 ef2:	90 e0       	ldi	r25, 0x00	; 0
 ef4:	62 e0       	ldi	r22, 0x02	; 2
 ef6:	48 eb       	ldi	r20, 0xB8	; 184
 ef8:	5b e0       	ldi	r21, 0x0B	; 11
 efa:	0e 94 54 00 	call	0xa8	; 0xa8 <OS_VOIDCreateTask>
	OS_VOIDCreateTask(&OS_VOIDAnimation1_2, 3, 3000); /* Task 3: Animation 1 - Stage 2 every 3000ms */
 efe:	89 ed       	ldi	r24, 0xD9	; 217
 f00:	90 e0       	ldi	r25, 0x00	; 0
 f02:	63 e0       	ldi	r22, 0x03	; 3
 f04:	48 eb       	ldi	r20, 0xB8	; 184
 f06:	5b e0       	ldi	r21, 0x0B	; 11
 f08:	0e 94 54 00 	call	0xa8	; 0xa8 <OS_VOIDCreateTask>
	OS_VOIDCreateTask(&OS_VOIDAnimation1_3, 4, 3000); /* Task 4: Animation 1 - Stage 3 every 3000ms */
 f0c:	84 ee       	ldi	r24, 0xE4	; 228
 f0e:	90 e0       	ldi	r25, 0x00	; 0
 f10:	64 e0       	ldi	r22, 0x04	; 4
 f12:	48 eb       	ldi	r20, 0xB8	; 184
 f14:	5b e0       	ldi	r21, 0x0B	; 11
 f16:	0e 94 54 00 	call	0xa8	; 0xa8 <OS_VOIDCreateTask>
	OS_VOIDCreateTask(&OS_VOIDAnimation1_4, 5, 3000); /* Task 5: Animation 1 - Stage 4 every 3000ms */
 f1a:	8f ee       	ldi	r24, 0xEF	; 239
 f1c:	90 e0       	ldi	r25, 0x00	; 0
 f1e:	65 e0       	ldi	r22, 0x05	; 5
 f20:	48 eb       	ldi	r20, 0xB8	; 184
 f22:	5b e0       	ldi	r21, 0x0B	; 11
 f24:	0e 94 54 00 	call	0xa8	; 0xa8 <OS_VOIDCreateTask>
	OS_VOIDCreateTask(&OS_VOIDAnimation2_1, 6, 3000); /* Task 6: Animation 2 - Stage 1 every 3000ms */
 f28:	8a ef       	ldi	r24, 0xFA	; 250
 f2a:	90 e0       	ldi	r25, 0x00	; 0
 f2c:	66 e0       	ldi	r22, 0x06	; 6
 f2e:	48 eb       	ldi	r20, 0xB8	; 184
 f30:	5b e0       	ldi	r21, 0x0B	; 11
 f32:	0e 94 54 00 	call	0xa8	; 0xa8 <OS_VOIDCreateTask>
	OS_VOIDCreateTask(&OS_VOIDAnimation2_2, 7, 3000); /* Task 7: Animation 2 - Stage 2 every 3000ms */
 f36:	85 e0       	ldi	r24, 0x05	; 5
 f38:	91 e0       	ldi	r25, 0x01	; 1
 f3a:	67 e0       	ldi	r22, 0x07	; 7
 f3c:	48 eb       	ldi	r20, 0xB8	; 184
 f3e:	5b e0       	ldi	r21, 0x0B	; 11
 f40:	0e 94 54 00 	call	0xa8	; 0xa8 <OS_VOIDCreateTask>
	OS_VOIDCreateTask(&OS_VOIDAnimation2_3, 8, 3000); /* Task 8: Animation 2 - Stage 3 every 3000ms */
 f44:	80 e1       	ldi	r24, 0x10	; 16
 f46:	91 e0       	ldi	r25, 0x01	; 1
 f48:	68 e0       	ldi	r22, 0x08	; 8
 f4a:	48 eb       	ldi	r20, 0xB8	; 184
 f4c:	5b e0       	ldi	r21, 0x0B	; 11
 f4e:	0e 94 54 00 	call	0xa8	; 0xa8 <OS_VOIDCreateTask>
	OS_VOIDCreateTask(&OS_VOIDAnimation2_4, 9, 3000); /* Task 9: Animation 2 - Stage 4 every 3000ms */
 f52:	8b e1       	ldi	r24, 0x1B	; 27
 f54:	91 e0       	ldi	r25, 0x01	; 1
 f56:	69 e0       	ldi	r22, 0x09	; 9
 f58:	48 eb       	ldi	r20, 0xB8	; 184
 f5a:	5b e0       	ldi	r21, 0x0B	; 11
 f5c:	0e 94 54 00 	call	0xa8	; 0xa8 <OS_VOIDCreateTask>
	OS_VOIDCreateTask(&OS_VOIDDoorChangePosition, 10, 20000); /* Task 10: Change door position every 20000ms */
 f60:	88 e8       	ldi	r24, 0x88	; 136
 f62:	91 e0       	ldi	r25, 0x01	; 1
 f64:	6a e0       	ldi	r22, 0x0A	; 10
 f66:	40 e2       	ldi	r20, 0x20	; 32
 f68:	5e e4       	ldi	r21, 0x4E	; 78
 f6a:	0e 94 54 00 	call	0xa8	; 0xa8 <OS_VOIDCreateTask>

	/* Initialize OS */
	OS_VOIDOSStart();  /* Start the OS and enable global interrupts */
 f6e:	0e 94 49 00 	call	0x92	; 0x92 <OS_VOIDOSStart>
 f72:	ff cf       	rjmp	.-2      	; 0xf72 <main+0xea>

00000f74 <__udivmodhi4>:
 f74:	aa 1b       	sub	r26, r26
 f76:	bb 1b       	sub	r27, r27
 f78:	51 e1       	ldi	r21, 0x11	; 17
 f7a:	07 c0       	rjmp	.+14     	; 0xf8a <__udivmodhi4_ep>

00000f7c <__udivmodhi4_loop>:
 f7c:	aa 1f       	adc	r26, r26
 f7e:	bb 1f       	adc	r27, r27
 f80:	a6 17       	cp	r26, r22
 f82:	b7 07       	cpc	r27, r23
 f84:	10 f0       	brcs	.+4      	; 0xf8a <__udivmodhi4_ep>
 f86:	a6 1b       	sub	r26, r22
 f88:	b7 0b       	sbc	r27, r23

00000f8a <__udivmodhi4_ep>:
 f8a:	88 1f       	adc	r24, r24
 f8c:	99 1f       	adc	r25, r25
 f8e:	5a 95       	dec	r21
 f90:	a9 f7       	brne	.-22     	; 0xf7c <__udivmodhi4_loop>
 f92:	80 95       	com	r24
 f94:	90 95       	com	r25
 f96:	bc 01       	movw	r22, r24
 f98:	cd 01       	movw	r24, r26
 f9a:	08 95       	ret

00000f9c <__divmodhi4>:
 f9c:	97 fb       	bst	r25, 7
 f9e:	09 2e       	mov	r0, r25
 fa0:	07 26       	eor	r0, r23
 fa2:	0a d0       	rcall	.+20     	; 0xfb8 <__divmodhi4_neg1>
 fa4:	77 fd       	sbrc	r23, 7
 fa6:	04 d0       	rcall	.+8      	; 0xfb0 <__divmodhi4_neg2>
 fa8:	e5 df       	rcall	.-54     	; 0xf74 <__udivmodhi4>
 faa:	06 d0       	rcall	.+12     	; 0xfb8 <__divmodhi4_neg1>
 fac:	00 20       	and	r0, r0
 fae:	1a f4       	brpl	.+6      	; 0xfb6 <__divmodhi4_exit>

00000fb0 <__divmodhi4_neg2>:
 fb0:	70 95       	com	r23
 fb2:	61 95       	neg	r22
 fb4:	7f 4f       	sbci	r23, 0xFF	; 255

00000fb6 <__divmodhi4_exit>:
 fb6:	08 95       	ret

00000fb8 <__divmodhi4_neg1>:
 fb8:	f6 f7       	brtc	.-4      	; 0xfb6 <__divmodhi4_exit>
 fba:	90 95       	com	r25
 fbc:	81 95       	neg	r24
 fbe:	9f 4f       	sbci	r25, 0xFF	; 255
 fc0:	08 95       	ret

00000fc2 <_exit>:
 fc2:	f8 94       	cli

00000fc4 <__stop_program>:
 fc4:	ff cf       	rjmp	.-2      	; 0xfc4 <__stop_program>
